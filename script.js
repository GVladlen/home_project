/* Задание на урок:

1) Создать переменную numberOfFilms и в неё поместить ответ от пользователя на вопрос:
'Сколько фильмов вы уже посмотрели?'

2) Создать объект personalMovieDB и в него поместить такие свойства:
    - count - сюда передается ответ на первый вопрос
    - movies - в это свойство поместить пустой объект
    - actors - тоже поместить пустой объект
    - genres - сюда поместить пустой массив
    - privat - в это свойство поместить boolean(логическое) значение false

3) Задайте пользователю по два раза вопросы:
    - 'Один из последних просмотренных фильмов?'
    - 'На сколько оцените его?'
Ответы стоит поместить в отдельные переменные
Записать ответы в объект movies в формате: 
    movies: {
        'logan': '8.1'
    }

Проверить, чтобы все работало без ошибок в консоли */

//'use strict';

// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// const a = prompt('Один из последних просмотренных фильмов?', ''),
//       b = prompt('На сколько оцените его?', ''),
//       c = prompt('Один из последних просмотренных фильмов?', ''),
//       d = prompt('На сколько оцените его?', '');  

// personalMovieDB.movies[a] = b;
// personalMovieDB.movies[c] = d;

// console.log(personalMovieDB);

//--------------------------------------------------------------------

/* Задание на урок:

1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
отменить ответ или ввести название фильма длинее, чем 50 символов. Если это происходит - 
возвращаем пользователя к вопросам опять

3) При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
"Просмотрено довольно мало фильмов", если от 10 до 30 - "Вы классический зритель", а если больше - 
"Вы киноман". А если не подошло ни к одному варианту - "Произошла ошибка"

4) Потренироваться и переписать цикл еще двумя способами*/



// Код возьмите из предыдущего домашнего задания
"use strict";
// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// // 1 задание
// // В const a,b,c,d, - вопросы повторялись два раза( не логично с точки зрения)
// // программирования, надо автоматизировать процесс(при помощи самого используемого 
// // цикла for):

// for(let i = 0; i < 2; i++) {     // задаем начальные условия (цикл настроен)
// // надо вписать действия, которые будут происходить каждый раз, когда он повторяется
//    const a = prompt('Один из последних просмотренных фильмов?', ''),
//          b = prompt('На сколько оцените его?', '');
//    if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//       personalMovieDB.movies[a] = b;
//       console.log('done');
//    } else{
//       console.log('error');
//       i--;
//    }
// далее записываем ответы в базу данных:

   
// Оставляем тaкие же названия переменных(технические переменные которые дальше 
// использовать не будем): a - свойство объекта, в - значение свойства объекта

// автоматизация закончена


// 2 задание
// Это надо выполнить внутри цикла и каждый раз проверять все те ответы который дал 
// пользователь в (if ()). В нем будет очень большое условие(надо будет проверить оба ответа, 
// как отменил ответ, на пустую строку или длину (length))
// Как мы можем проверить что пользователь нажал кнопку 'отмена'?
// Когда используется prompt - есть выбор 'ок' или 'отмена': при нажатии отмена в переменную a
// выводится null( можно посмотреть в консоле), тогда будем проверять переменную а 
// на соответствие null,  но в условии лучше будем работать в обратном ключе
// т.е. если пользователь ввел непустую строку и не нажал на кнопку 'отмена' и название
// фильма не длиннее чем 50 символов:  тогда будем что делать
// тогда будем использовать оператором отрицания - "!".
// (a != null) - пользователь не нажал на кнопку 'отмена' на первый вопрос
// && - оператор логический "И"
// проверяем (b != null) - и второй ответ не является отменненым
// проверяем (a != '') - переменная 'a' не является пустой строкой
// (b != '') - не является пустой строкой
// (&&a.length < 50) - ответ не длиннее 50 символов
// И если все условия не выполняются, т.е. пользователь все ввел правильно
// записываем  в  фигурных скобках {personalMovieDB.movies[a] = b;}
// для проверки console.log('done');
// Если что то происходит непавильно то возвращаем пользователя к вопросам опять
// применяем оператор else
// console.log - для вывода ошибки
// И как же нам вернуть к вопросам? Если условия не выполнены
// Нужно вернуть цикл на одно повторение назад
// применяем оператор декремента (i--)(минус минус):
// т.е. если условие if не выполнилось, вернемся на одно повторения, одну иттерацию цикла назад
// и зададим вопросы пользователю заново, и так будет всегда если условия не выполнятся
// 2 задание выполнено при помощи цикла  скомбинированного вместе с условием
// Желательно код проговорить простыми словами например(a != null -  переменная а не равняется пустой строке)

// 3 задание
// if (personalMovieDB.count < 10) {
//     console.log("Просмотрено довольно мало фильмов");
// } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
//     console.log("Вы классический зритель");
// } else if (personalMovieDB.count >= 30) {
//     console.log("Вы киноман");
// } else {
//     console.log("Вы киноман");
// }

// console.log(personalMovieDB);

// switch - не можем использовать т.к. он используется для прямого сравнения (=10, =30)


// -----------Урок 16 ------------------------------------
// Функции и стрелочные функции

/*
 Функции - это наши действия в JavaScriptе: они используют различные типы данных,
 изменяют информацию так, как мы укажем, значительно сокращают код, как циклы.
 Можно представить функцию как калькулятор.
*/
// (аргументы), {действия}

// let num = 20;

// function showFirstMessage(text) {
//     console.log(text);
//     // let num = 10; 
//     console.log(num);          // изменили(переопределили) переменную (было num=10)
//  }
//  showFirstMessage("Hello World");
//  console.log(num);        //чтобы функция заработала надо ее вызвать
 /*
 одно из главных вещей функции - ее имя
  оно должно быть глаголом с припиской того, над чем выполняется действие
 (например: showFirstMessage - показать первое сообщение ).
 Есть анонимные функции(без имени) - они вызываются и используются здесь и сейчас
 только один раз.
 аргументы записываются в (), когда функция вызывается, можем дать какие-то данные
 которые она будет использовать внутри себя
 При использовании аргумента (text) VSCode подсвечиваеn,  что этот аргумент используется.
 Теперь чтобы функция отработала, аргумент надо передать в showFirstMessage("Hello World");
 Когда функция запустится, она возьмет строку которую мы ей передали"Hello World",
  подставит вместо text в function showFirstMessage(text), и засунет вместо text в
  console.log(text)
  Аргументов может быть бесконечное количество(чтобы записать еще аргумент ставим запятую).
  Если переменная создана внутри функции (в {} скобках) она называется локальной и
  видна только в области видимости
  Если переменную вывести из фигурных скобок и переместить перед функцией она станет
  глобальной т.е. функция будет использовать глобальную переменную (часто используемый
  прием)
  Если в функции запишем let num = 10 то при выполнении кода в консоли выйдет 20 -
  т.к.  let num = 20 это глобальная переменная, которая видна везде.

  Что такое замыкание
  Когда функция вызывается, то по факту она пытается найти  переменные, значения
  внутри себя(функции) и если не находит, то она переходит на уровень выше, до самого
  высшего уровня, который ей вообще доступен.

//   Замыкание функции - это сама функция вместе со всеми внешними переменными, 
                        которые ей доступны

 Кроме всех действий функция может вернуть какое-либо значение при помощи ключевого
 слова return. Как только функция увидит return - она прекратит свое действие
 */

//  function calc(a, b) {      // Это значит когда запустится функция calc 
//      return (a+b);          // она вернет сумму а и в аргументов
//    //console.log("dwed")    // после return код никогда не выполнится
//                             //  после return ничего не задаем
//  }
//  // Теперь эту функцию можем переиспользовать много раз
//  // Функция это один из принципов оптимизации кода

//  console.log(calc(4, 3));
//  console.log(calc(5, 6));
//  console.log(calc(10, 6));  
//  // каждый раз используем функцию с различными аргументами 
//  // в этом заключается суть функции - автоматизации процессов

//  // У return есть еще одно применение не только окончание функции, но и возвращение
//  // значения наружу:
//  // на практике эт часто используется

//  function ret() {
//      let num = 50;

//     // здесь может выполняться огромный код (например:логика работы с зарплатами, какими-то данными и.т.д.)

//      return num;
// // функция возвращает значение локальной переменной num
// // т.е. возвращается результат работы функции
//  }
// //  и его мы можем куда-то записать:
// // в переменную anotherNum помещаем результат работы функции ret();
// const anotherNum = ret();
// // и чтобы проверить
// console.log(anotherNum);
// // Получаем 50, потому что 50 вышла наружу const anotherNum = ret();

// // Классификация функций ---------------------------------

// // 1 Function Declaration

// function foo() {
//     // код
// }               // при Function Declaration точку с запятой (;) не ставим

// Она существует еще до того, как наш код запустится
//(например: как переменная var - она существует до того, когда ее объявили, 
// тоже самое и с функцией)
// Создается до начала выполнения скрипта, можно вызвать перед объявлением
/*
Как это работает: Когда html-страница загружается попорядку, доходит до скрипта -
скрипт начинает загружаться. Первым делом браузер пробегается по скрипту и 
находит все переменные var(если они там есть) и все Function Declaration.
Он их создает, он их объявляет и после этого код начинает выполняться,
и все опять идет по порядку(сверху вниз)

 Преимущества этого подхода: если функция существует до того как она объявлена,
 то мы можем например: фукцию calc можем использовать таким образом:

 console.log(calc(4, 3));
 console.log(calc(5, 6));
 console.log(calc(10, 6)); 

 function calc(a, b) { 
    return (a+b);          
 }
    и это не вызовет никаких ошибок, т.е. функция работает до того как она была вызвана
Иногда разработчики прием используют: что все функции которые созданы в одном из файлов
они помещают в самый низ страницы, а сверху только используют.
*/

// 2 Function Expression

// Главное отличие от Function Declaration:
// Создается только тогда, когда доходит поток кода, 
// можно вызвать только после объявления 

// Это функциональное выражение
// Сперва должны создать переменнную и вовнутрь поместить функцию.

// let food = function() {
//     // код
//     console.log("Good");
// };          // при Function Expression точка с запятой (;) обязательна,
            // т.к. это переменная и значение функции ее внутреннее состояние

//Например:

// const logger = function() {
//     console.log("Hello");
// };
//     logger();       // вызов функционального выражения





// 3 Стрелочные фукции-------------------------------
// Современный стандарт ES6 в 2015 году.

// () =>

// Не имеет своего контекста вызова

// Пример:
// const calc = (a, b) => a + b;
// создаем переменную, в которую помещаем функцию (функция стрелочная)
// => указывает на выполнения кода

// В классическом варианте
// const calc = (a, b) => { return a+b};
// Позволяет значительно сократить код, чтобы использовать надо знать ее особенности
// 
// Главное не имеет своего контекста вызова, поэтому чаще всего встречается в обработчиках событий
// Если функция в одну строчку то можно без фигурных скобок
// Если функция содержит один аргумент:
// const calc = a => a + b;
// Если функция разрастается {} раскрываются и внутри производятся определенные действия
// const calc = (a, b) => {
//     console.log('1');
//     return a + b;
// }

// ----------Урок 17--------------------------------------

// ----- СТРОКИ----------------------------------

// Методы и свойства строк и чисел

// Методы - это вспомогательные функции
// Свойства - это вспомогательные значения

// такие же понятия встречаются в объектах

// Рассмотрим самые основные:

// const str = "test";

// console.log(str.length);
// получим 4 - количество символов в строке (в слове test)

// часто используемое свойство чтобы получить как длину строки, так и других данных
// таких как количество элементов внутри массива, например:

// const arr = [1, 2, 4];

//  console.log(arr.length);
 // Получим 3 - кол-во элементов в массиве
 // Когда используем свойство (например: lendth), мы его не вызываем, а
 // пишем через точку(.length)
 // методы пишутся с () в конце
 // Получение сведений о методах и свойствах string в браузере:
 // console.dir(Number) -  выводит элемент в виде объекта(методы, свойства)

 // Использование в консоли браузере console.dir: можно посмотреть различные свойства,
 // методы и как использовать.

 // Как использовать:

 // Попробуем получить часть строки через индекс
//  const str = "test";
//  const arr = [1, 2, 4];

//  console.log(str[2]);
 // получим: s

//  const str = "test";
//  const arr = [1, 2, 4];

//  console.log(str[2] = 'd'); // ошибка: если поменять символ s на d - не получится:
 // когда строка записана так "test" на прямую изменить не можем - для этого есть другие методы:

 // Изменение регистра

//  const str = "test";

//  console.log(str.toUpperCase());  //(.toUpperCase() - метод)т.е. выполняем действие над сторокой
//  console.log(str);
 /*
в консоли видим что test превратился в TEST(верхние регистр), но предыдущее значение 
в str не поменялось, это означает что кусок кода str.toUpperCase() возвращает
новое значение, оно напрямую не изменяет строку которое было в исходных данных, а 
новое значение мы можем использовать в дальнейшем: в console.log или записать в
другую переменную и т.д.
*/

// тоже самое будет и с toLowerCase(превращает в нижний регистр):
// const str = "teSt";

// console.log(str.toLowerCase());  //(.toUpperCase() - метод)т.е. выполняем действие над сторокой
// console.log(str);
// применяется для превращение строки в единый формат( в примере - нижний регистр,
// при опечатке польз-я)
// Очень часто используются

// Метод который позволяет найти кусок строки и сказать с  какого индекса, с какой 
// позиции она начинается. В официальной документации программирования 
// называется: Поиск подстроки
// Пример:

// const fruit = "Some fruit";

// console.log(fruit.indexOf("fruit"));
// .indexOf - тоже метод и должен принимать в себя какой-то аргумент,
// Попытаемся найти кусок строки и найти с какого индекса начинается
// например мы хотим найти "fruit" - в консоли получится 5 т.к. в строке
// "Some fruit" - перед fruit - 4 буквы и 1 пробел
// Такой метод используется и для того чтобы определить, а действительно 
// ли в этой строке есть искомое значение

// const fruit = "Some fruit";

// console.log(fruit.indexOf("q"));
// Здесь покажет -1 - т.е. это не было найдено

// Вопрос: Если строка не изменяема, то какже мы можем ее модифицировать или 
// ее как-то поменять?

// Будем разбирать методы, которые взаимодействуют со строками
// Всего их JavaScript - 3(три)

// 1 Метод .slice (слайс)

// const logg = "Hello world";
// // чтобы модифицировать эту строку воспользуемся методом slice (слайс)
// // и говорим что мы  хотим вернуть из этой строки
// console.log(logg.slice(6, 10));
// Синтаксис () - задаем 2 аргумента( 2 значения (start и end)): 
// 1 говорит - с какой части строки необходимо возвращать что-то (6)
// Задача: отрезать world  и как-то использовать 
// 2 - где нам заканчивать непосредственно это вырезание куска строки (10)
//  В консоли получится: worl (обрежется последняя буква)
// Потому что когда используем  slice, в аргументе end( во втором аргументе(10))
// указываем то, что не включается т.е. до какого-то момента, но не включая его
// Есть еще одно использование метода slice - можно указать только один аргумент
// т.е. с чего начинать - это значит строка будет вырезаться просто до конца
// Эти методы очень часто используются
// slice поддерживает и отрицательные значения, например:
// const logg = "Hello world";

// console.log(logg.slice(-5, -1));
// Получим worl(отсчет с конца строки) - применяется редко

// 2 Метод .substring (субстринг)

// const logg = "Hello world";

// console.log(logg.substring());
// также 2 аргумента: start и end

// Отличие .substring от .slice:
// разница в том что 1 аргумент можно задать больше чем 2 аргумент(не стоит так делать)
// и .substring - не поддерживает отрицательные значения
//(если будет -6 - будет интерпретироваться как ноль(0))

// 3 метод substr

// const logg = "Hello world";

// console.log(logg.substr(6, 5));
// Главное отличие: вместо 2 аргумента(end) указываем длину, сколько символов
// необходимо вырезать
// получим: world 

// --------ЧИСЛА ----------------------------------

//В JavaScript есть мини библиотека, которая существует внутри браузера, внутри 
// JavaScript - Math. В котором много математеческих свойства и методы
// Пример: Округление 
// Округление к ближайшему целому числу

// const num = 12.2;
// console.log(Math.round(num));

// parseInt() - переводит число в другую форму исчисления

// const test = "12.2px";
// console.log(parseInt(test));
// получим 12 и это числовой тип данных, когда строка переводится в число
// когда строка обрезается и остается целое число
// часто используется

// parseFloat() - используется для перевода(число или строку) в десятичном варианте

// const test = "12.2px";
// console.log(parseFloat(test));
// получим 12.2


//-------------Урок 18-----------------------------------------
// Практика, ч3. Использование функций
//-------------Урок 18-----------------------------------------
// Практика, ч3. Использование функций 

// 1) Первую часть задания повторить по уроку

// 2) Создать функцию showMyDB, которая будет проверять свойство privat. Если стоит в позиции
// false - выводит в консоль главный объект программы

// 3) Создать функцию writeYourGenres в которой пользователь будет 3 раза отвечать на вопрос 
// "Ваш любимый жанр под номером ${номер по порядку}". Каждый ответ записывается в массив данных
// genres

// P.S. Функции вызывать не обязательно*/



// Код возьмите из предыдущего домашнего задания

// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');
// // 1) Первую часть задания повторить по уроку

// function start() {

// }
// в функцию помещаем действие (const numberOfFilms = 
// +prompt('Сколько фильмов вы уже посмотрели?','');) и добавим проверку:
// чтобы пользователь не отменил, не ввел пустую строку, и ввел нечисло
// проверять будем на этапе выполнения(когда пользователь нажал кнопку ОК),
// но если хотим проверить на этапе ввода(когда пользователь печатает в input)
// надо использовать регулярные выражения( будет ниже )

// Если мы будем использовать personalMovieDB(базу данных) внутри функции start() как 
// глобальную переменную, то она превратится в локальную(внутри переменной) и мы
// не сможем ее записать в (const personalMovieDB = {       
//    count: numberOfFilms)
//     --//--
//}     // можно обойти при помощи return
// Сделаем по другому
// const personalMovieDB = {       // наша база данных - идет как глобальная переменная
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// 1 задание----------------------------------------

// let numberOfFilms;  // меняем const на let(т.к. будем менять содержание константы)
// // теперь она переменная объявленная глобально

// function start() {
//     numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');

// // Здесь будут проверки другим циклом while ( пока чтото у нас происходит или не происходит? 
// //то будем выполнять какие-то действия)
//     while(numberOfFilms == '' || numberOfFilms == null || isNaN(numberOfFilms)) { 
// // проверка на пустую строку(=='') или пользователь отменяет действие (== null) или
// // пользователь ввел не число(isNaN(numberOfFilms))(проверяет если внутри не число,
// // то он возвращает правду т.е. если введет буквы то это будет не число)
// // Когда мы создали такую проверку:
// // цикл будет выполняться пока одно из этих условий будет правдивым( т.е. пустая строка, 
// // нажатие кнопки "Отмена", или введено не число)
// // И повторяем вопрос пользователю
//         numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');
//     }    
// }
// // после этого вызываем функцию start
// start();

// const personalMovieDB = {       // наша база данных - идет как глобальная переменная
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// // здесь мы проверяли при помощи цикла(for(let i = 0; i < 2; i++) и условиями 
// // if и else внутри


// // Это цикл(for(let i = 0; i < 2; i++)) будем вызывать по требованию
// // т.е. создать функцию которая будет ее оборачивать

// function rememberMyFilms() {    // запомнить те фильмы, которые сюда приходили
// // и вырезать весь цикл (for(let i = 0; i < 2; i++)) и поместить внуть этой функции
    
//     for(let i = 0; i < 2; i++) {     // задаем начальные условия (цикл настроен)
//         // надо вписать действия, которые будут происходить каждый раз, когда он повторяется
//         const a = prompt('Один из последних просмотренных фильмов?', ''),
//                 b = prompt('На сколько оцените его?', '');
        
//         if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//             personalMovieDB.movies[a] = b;
//             console.log('done');
//         } else{
//             console.log('error');
//             i--;
//         }
//     }
// }
// // и не забываем ее вызвать
// // rememberMyFilms(); 
// // т.е. функция вызовется и внутри сработает цикл


// // Обворачиваем и следующие условия(if (personalMovieDB.count < 10) { ) 
// // (помещяем во внутрь функции function detectedPersonalLevel() { )

// function detectedPersonalLevel() {
//     if (personalMovieDB.count < 10) {
//         console.log("Просмотрено довольно мало фильмов");
//     } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
//         console.log("Вы классический зритель");
//     } else if (personalMovieDB.count >= 30) {
//         console.log("Вы киноман");
//     } else {
//         console.log("Произошла ошибка");
//     }

// }
// // И вызываем функцию
// // detectedPersonalLevel();

// // Теперь есть функции которые занимаются определенными вещами и вызываются
// // когда необходимы

// // 2 задание -----------------------------------

// function showMyDB(hidden) {
// // тут проверяем условие
//     if (!hidden) {                      // если наша база данных не скрыта,
//         console.log(personalMovieDB);   // то мы ее показываем
//     }
// }
// // т.к. в нашей базе данных (const personalMovieDB = { ) 
// // privat: false, то в функции (function showMyDB(hidden) { )
// // в условии (if (!hidden) { ) (! - отрицание), то false - превращается в true 
// // функция готова и вызываем ее:

// showMyDB(personalMovieDB.privat);
// // при вызове функции в качестве аргумента в() передаем кусочек базы данных
// // если без аргумента ничего страшного нет - это тоже правильный подход

// // теперь протестируем
// // для этого функции закомментируем
// // проверим при данных privat: false - база данных 
// // в консоли показана
// // проверим при privat: true - база данных не видна


// // 3 задание--------------------------

// // function writeYourGenres() {
// //     // здесь будем три раза задавать вопрос и создаем цикл
// //     // и начнем с 1, т.к. пользователь не знает что в программировании начинается с 0.(i = 1;)
// //     // цикл повторяется 3 раза (i <= 3)

// //     for (let i = 1; i <= 3; i++) {
// //         // далее задаем пользователю вопрос
// //         // меняем на бектики(``) и в {} вставляем i
// //         const genre = prompt(`Ваш любимый жанр под номером ${i}`);
// //         // вторая часть задания записать в базу данных ответ пользователя
// //         // когда записываем в базу данных то должны начинать с 0(ноля) [i -1].
// //         personalMovieDB.genres[i - 1] = genre;
// //     }
// // }
// // так же функцию можно записать по другому: результат такой же

// function writeYourGenres() {
//     for (let i = 1; i <= 3; i++) {
//         personalMovieDB.genres[i - 1] = prompt(`Ваш любимый жанр под номером ${i}`);
//     }
// }
// // вызываем функцию
// writeYourGenres();

// ------------Урок 19---------------------------------
// Callback - функции

// Callback - функции - это функция которая должна быть выполнена, после того
// другая функция завершила свое выполнение (часто применяется)

function first() {
    // Do something (Сделай что-нибудь)
    //Данная функция имеет какую-то задержку: задержка (функция может общаться с сервером,
    // и сервер ответит через полсекунды или обработка данных, которые требуют времени
    // сэмулируем такое поведение с помощью конструкции, которая делает определенную
    // задержку в нашем коде: получится задержка в полсекунды(500 миллисекунд)
    setTimeout(function() {
        console.log(1);
    }, 500); 
    // через полсекунды в консоль выведется 1
}

function second() {
    console.log(2);
}
// не забываем вызвать функции
first();
second();
// получаем сперва 2 потом 1, то есть 2 функция сработала раньше из-за задержки в 500мс
// но если смотреть на код не все становится очевидным, т.к. функции при вызове 
// должны строго выполниться одна за другой и поэтому можем получить непредсказуемый 
// результат, особенно важно когда эти функции работают с одними и теми же данными
// Запомнить: если функции идут одна за другой, это не значит что они выполняются
// так же.

// Callback - функции - это функция которая должна быть выполнена, после того
// другая функция завершила свое выполнение (часто применяется)

// Пример функции:
// function learnJS(lang, callback) {      // главный шаблон callback-функции
// // в lang- передадим 1 аргумент(какойто-то язык)
// // в Calback - то что в другую функцию в качестве аргумента в будущем мы сможем
// // передать другую функцию
//     console.log(`Я учу: ${lang}`);
// // и дальше чтобы вызвать callback-функцию, которая тоже будет передана как аргумент
// // берем ее и вызываем:
//     callback();
// // т.е. когда выполнится первое действие от первой функции (console.log(`Я учу: ${lang}`);)
// // выполнится вторая функция (callback();)
// }
function learnJS(lang, callback) {  
    console.log(`Я учу: ${lang}`);
    callback();
}
learnJS('JavaScript', function(){
    console.log('Я прошел этот урок');
});
// таким образом должна соблюдаться последовательность функций(часто применяемый прием)
// function(){} - анонимная функция(без аргументов)- вместо нее можно передать
// осознанную функцию - 

// Пример вместо предыдущей функции (вместо анонимной функции
// передадим (function done() {} )) :

function learnJS(lang, callback) {  
    console.log(`Я учу: ${lang}`);
    callback();
}

function done() {
    console.log('Я прошел этот урок');
}

learnJS('JavaScript', done);

// Один из важных моментов это то как передаем эту функцию,
// без скобок (done()) т.к. передали только функцию
// мы сказали: функция learnJS выполни функцию done тогда, когда дойдешь до callback()
// done как функция передается вместо callback и внутри function learnJS(lang, callback) { 
// и когда нужно вызывается и поэтому в learnJS('JavaScript', done); не ставим () скобки
// Потому что мы не вызываем функцию, а передаем чтобы в дальнейшем была использована.

// Если говорить о практике, то мы будем использовать callback постоянно при запросах 
// к серверу либо если в серверном программировании на node.js? где почти все построено 
// на таких callback-ах
// На следующих уроках будем работать с событиями, которые происходят на странице
// Например: когда пользователь только кликнул на странице(т.е. первый аргумент),
// только после этого передаем callback-функцию которая выполняется строго после клика.
// Т.к. JavaScript весь построен на интерактиве мы постоянно будем ловить действия
// пользователя и после них, при помощи таких коллбэков выполнять определенные действия.

// Итоги:
// callback-и позволяют нам быть уверенными в том, что определенный код не начнет исполнение
// до того момента, пока другой код не завершит свое исполнение