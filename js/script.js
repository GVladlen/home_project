/* Задания на урок:

1) Удалить все рекламные блоки со страницы (правая часть сайта)

2) Изменить жанр фильма, поменять "комедия" на "драма"

3) Изменить задний фон постера с фильмом на изображение "bg.jpg". Оно лежит в папке img.
Реализовать только при помощи JS

4) Список фильмов на странице сформировать на основании данных из этого JS файла.
Отсортировать их по алфавиту 

5) Добавить нумерацию выведенных фильмов */

'use strict';

const movieDB = {
    movies: [
        "Логан",
        "Лига справедливости",
        "Ла-ла лэнд",
        "Одержимость",
        "Скотт Пилигрим против..."
    ]
};

// Практика
// 1) Удалить все рекламные блоки со страницы (правая часть сайта)
// в консоли находим класс рекламного блока с картинками
// копируем класс и создаем константу adv с поиском выбранного класса
// при помощи querySelectorAll

const adv = document.querySelectorAll('.promo__adv img');
const poster = document.querySelector('.promo__bg');
const genre = poster.querySelector('.promo__genre');
const movieList = document.querySelector('.promo__interactive-list');

// Вариант со стрелочной функцией
// предпочтительнее для использования

adv.forEach(item => {
   item.remove();
});

// Вариант с обычной функцией
// adv.forEach(function (item) {
//    item.remove();
// });
// это безымянная функция, которая создается здесь и сейчас
// и принимает только один аргумент item? который приходит из
// псевдомассива

// 2) Изменить жанр фильма, поменять "комедия" на "драма"
// создаем переменную genre и записываем в одной структуре с 
// остальными переменными в начале кода
// т.к. блок .promo__genre, с которым мы будем работать сейчас 
// находится в блоке .promo__bg,с которым будем работать после
// 2 задания, то в структуре переменных создадим новую переменную
// poster(poster = document.querySelector('.promo__bg')
// т.е. можно четко сказать что блок .promo__genre находится в
// блоке .promo__bg(genre = poster.querySelector('.promo__genre').)

// т.к. изменяем только текст применим textContent

genre.textContent = 'драма';

// 3) Изменить задний фон постера с фильмом на изображение "bg.jpg". Оно лежит в папке img.
// Реализовать только при помощи JS

poster.style.backgroundImage = 'url("img/bg.jpg")';

// 4) Список фильмов на странице сформировать на основании данных 
//    из этого JS файла.
// Отсортировать их по алфавиту 

// Мы берем названия фильмов из массива movies и помещаем их
// каким-то образом на страницу
// Сперва удалим элементы со страницы(статичная верстка) чтобы
// они не мешали. Нужно найти родителя удаляемых элементов
// и записать в переменную (const moviList = document.querySelector('.promo__interactive-list');
// чтобы полностью очистить этот элемент, есть метод innerHTML

movieList.innerHTML = "";

// если поставить- "" - (ничего) - то элемент очистится и ничего не 
// будет содержать.

// теперь сортировка по алфавиту:

movieDB.movies.sort();
// теперь все отсортировано по алфавиту.
// далее необхоимо сформировать верстку при помощи JS
// и поместить на страницу

// Все элементы с которыми будем взаимодействовать находятся в
// базе данных movieDB в свойстве movies, нам надо будет перебрать все 
// значения, которые находятся в массиве:
// const movieDB = {
//    movies: [
//        "Логан",
//        "Лига справедливости",
//        "Ла-ла лэнд",
//        "Одержимость",
//        "Скотт Пилигрим против..."
//    ]
// };
// и уже на их основании сформировать структуру
// поэтому если мы проговариваем, что нам надо необходимо перебрать 
// прописываем метод forEach, во внутрь прописываем колбэк-функцию,
// здесь понадобиться 2 аргумента: film(это каждый фильм в массиве),
// и переменная i(номер по порядку, т.к. в 5 задании нужно добавить 
// нумерацию)
// Какой самый оптимизированный способ помещать элементы и генерировать
// их вручную, это прописывать их строками и просто добавлять еще
// каждый раз строку, когда повторяется цикл
// (помимо этого есть еще вариант, когда вручную создаем каждый отдельный
//  элемент при помощи createElement, добавляем класс, добавляем 
// внутренность на основании массива и уже потом помещаем на страницу,
// но это не очень оптимизированный вариант - слишком много операций -
// это тоже рабочий вариант) 

movieDB.movies.forEach((film, i) => {
   movieList.innerHTML += `
      <li class="promo__interactive-item">${i + 1} ${film}
         <div class="delete"></div>
      </li>
   `;
});

// нам необходимо всю верстку, которую сформируем поместить на страницу
// для этого есть блок movieList - который ранее почистили
// потом чтобы туда поместить html - прописываем innerHTML,
// дальше воспользуемся оператором  +=(дополнительное присваивание
// смотри таблицу операторов) - это сокращенная форма для записи
// определенной конструкции. Как это работает пример:
/*
Если у нас есть переменная a, в которую я хочу записать ее предыдущее
значение a только + 1, то можем записать такое выражение:
a = a + 1;
но также есть облегченный синтаксис
a += 1;
или
a = a + "aaa";
a += "aaa";
*/
/*
Особенность innerHTML - научились очищать элемент(movieList.innerHTML = "";),
но при этом также можем получать весь контент, который находится 
внутри определенного элемента, посмотрим как это выглядит:

console.log(poster.innerHTML);(используется не так уж часто)

и дальше ничего не присваиваю, т.е. только прописываю свойство
и помним что наш элемент объект у него есть свойство innerHTML 
если так к нему обращаемся, то просто получаем значение этого свойства
в консоли браузера

Когда имеем такую конструкцию
movieDB.movies.forEach((film, i) => {
   movieList.innerHTML +=
});
каждый раз когда будет цикл (film, i) повторяться
в  movieList.innerHTML += сюда будем добавлять и еще добавлять
какието-то строки
затем после movieList.innerHTML += поставим бэктики(``) потому-что
будем добавлять еще определенные переменные в том числе i.
Теперь посмотрим какую верстку нужно сформировать, находим
li с item которые с фильмами, скопируем последний и вставим 
в бэктики (``), так как прямо здесь же генерируем такую верстку,
если оставим все так:

movieDB.movies.forEach((film, i) => {
   movieList.innerHTML += `
      <li class="promo__interactive-item">СКОТТ ПИЛИГРИМ ПРОТИВ...
         <div class="delete"></div>
      </li>
   `;
});
то forEach повториться 5 раз и каждый раз будет записываться такая
структура:

   <li class="promo__interactive-item">СКОТТ ПИЛИГРИМ ПРОТИВ...
      <div class="delete"></div>
   </li>
и увидим что сформировалось 5 элементов, они не динамичные,
каждый раз при переборе forEach записывали новый элемент в виде строки
(строка на странице при помощи innerHTML интерпретируется как верстка)
если уберем +, то каждый раз на каждом цикле, на каждой иттерации
будет замещаться это значение, в итоге получим только один элемент 
 и дополним в зависимости от того что есть в базе данных
 мы находим то что написано внутри этого элемента:
 СКОТТ ПИЛИГРИМ ПРОТИВ... удаляем его
 и вместе с 5 заданием добавим нумерацию просмотренных фильмов:
у нас есть переменная i(номер по порядку) - ставим знак интерполяции
${i + 1} -то есть начнем с 1 и до последнего фильма

теперь о самом фильме: у нас есть переменная film(еще у нас не используется)
по факту film это будет каждый элемент который лежит в внутри массива
movies, а внутри массива лежит строка, надо ее взять и поместить на страницу
ставим пробел и запишем ${film} и теперь наши фильмы будут формироваться
динамически: ${film} - будет идти из массива каждого элемента, а 
${i + 1} - нумерация будет автоматически
*/

