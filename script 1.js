"use strict";
// Задание----------------------------------------------------------------
// let numberOfFilms;

// function start() {
//     numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

//     while(numberOfFilms == '' || numberOfFilms == null || isNaN(numberOfFilms)) {
//         numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');
//     }
// }

// start();

// const personalMovieDB = {
//         count: numberOfFilms,
//         movies: {},
//         actors: {},
//         genres: [],
//         privat: false
// };

// function rememberMyFilms() {    // запомнить те фильмы, которые сюда приходили
// // и вырезать весь цикл (for(let i = 0; i < 2; i++)) и поместить внуть этой функции
    
//     for(let i = 0; i < 2; i++) {     // задаем начальные условия (цикл настроен)
//         // надо вписать действия, которые будут происходить каждый раз, когда он повторяется
//         const a = prompt('Один из последних просмотренных фильмов?', ''),
//                 b = prompt('На сколько оцените его?', '');
        
//         if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//             personalMovieDB.movies[a] = b;
//             console.log('done');
//         } else{
//             console.log('error');
//             i--;
//         }
//     }
// }
// // и не забываем ее вызвать
// rememberMyFilms(); 
//-----------------------------------------------------------------------------------
/* Задание на урок:

1) Создать переменную numberOfFilms и в неё поместить ответ от пользователя на вопрос:
'Сколько фильмов вы уже посмотрели?'

2) Создать объект personalMovieDB и в него поместить такие свойства:
    - count - сюда передается ответ на первый вопрос
    - movies - в это свойство поместить пустой объект
    - actors - тоже поместить пустой объект
    - genres - сюда поместить пустой массив
    - privat - в это свойство поместить boolean(логическое) значение false

3) Задайте пользователю по два раза вопросы:
    - 'Один из последних просмотренных фильмов?'
    - 'На сколько оцените его?'
Ответы стоит поместить в отдельные переменные
Записать ответы в объект movies в формате: 
    movies: {
        'logan': '8.1'
    }

Проверить, чтобы все работало без ошибок в консоли */

//'use strict';

// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// const a = prompt('Один из последних просмотренных фильмов?', ''),
//       b = prompt('На сколько оцените его?', ''),
//       c = prompt('Один из последних просмотренных фильмов?', ''),
//       d = prompt('На сколько оцените его?', '');  

// personalMovieDB.movies[a] = b;
// personalMovieDB.movies[c] = d;

// console.log(personalMovieDB);

//--------------------------------------------------------------------

/* Задание на урок:

1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
отменить ответ или ввести название фильма длинее, чем 50 символов. Если это происходит - 
возвращаем пользователя к вопросам опять

3) При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
"Просмотрено довольно мало фильмов", если от 10 до 30 - "Вы классический зритель", а если больше - 
"Вы киноман". А если не подошло ни к одному варианту - "Произошла ошибка"

4) Потренироваться и переписать цикл еще двумя способами*/



// Код возьмите из предыдущего домашнего задания

// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// // 1 задание
// // В const a,b,c,d, - вопросы повторялись два раза( не логично с точки зрения)
// // программирования, надо автоматизировать процесс(при помощи самого используемого 
// // цикла for):

// for(let i = 0; i < 2; i++) {     // задаем начальные условия (цикл настроен)
// // надо вписать действия, которые будут происходить каждый раз, когда он повторяется
//    const a = prompt('Один из последних просмотренных фильмов?', ''),
//          b = prompt('На сколько оцените его?', '');
//    if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//       personalMovieDB.movies[a] = b;
//       console.log('done');
//    } else{
//       console.log('error');
//       i--;
//    }
// далее записываем ответы в базу данных:

   
// Оставляем тaкие же названия переменных(технические переменные которые дальше 
// использовать не будем): a - свойство объекта, в - значение свойства объекта

// автоматизация закончена


// 2 задание
// Это надо выполнить внутри цикла и каждый раз проверять все те ответы который дал 
// пользователь в (if ()). В нем будет очень большое условие(надо будет проверить оба ответа, 
// как отменил ответ, на пустую строку или длину (length))
// Как мы можем проверить что пользователь нажал кнопку 'отмена'?
// Когда используется prompt - есть выбор 'ок' или 'отмена': при нажатии отмена в переменную a
// выводится null( можно посмотреть в консоле), тогда будем проверять переменную а 
// на соответствие null,  но в условии лучше будем работать в обратном ключе
// т.е. если пользователь ввел непустую строку и не нажал на кнопку 'отмена' и название
// фильма не длиннее чем 50 символов:  тогда будем что делать
// тогда будем использовать оператором отрицания - "!".
// (a != null) - пользователь не нажал на кнопку 'отмена' на первый вопрос
// && - оператор логический "И"
// проверяем (b != null) - и второй ответ не является отменненым
// проверяем (a != '') - переменная 'a' не является пустой строкой
// (b != '') - не является пустой строкой
// (&&a.length < 50) - ответ не длиннее 50 символов
// И если все условия не выполняются, т.е. пользователь все ввел правильно
// записываем  в  фигурных скобках {personalMovieDB.movies[a] = b;}
// для проверки console.log('done');
// Если что то происходит непавильно то возвращаем пользователя к вопросам опять
// применяем оператор else
// console.log - для вывода ошибки
// И как же нам вернуть к вопросам? Если условия не выполнены
// Нужно вернуть цикл на одно повторение назад
// применяем оператор декремента (i--)(минус минус):
// т.е. если условие if не выполнилось, вернемся на одно повторения, одну иттерацию цикла назад
// и зададим вопросы пользователю заново, и так будет всегда если условия не выполнятся
// 2 задание выполнено при помощи цикла  скомбинированного вместе с условием
// Желательно код проговорить простыми словами например(a != null -  переменная а не равняется пустой строке)

// 3 задание
// if (personalMovieDB.count < 10) {
//     console.log("Просмотрено довольно мало фильмов");
// } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
//     console.log("Вы классический зритель");
// } else if (personalMovieDB.count >= 30) {
//     console.log("Вы киноман");
// } else {
//     console.log("Вы киноман");
// }

// console.log(personalMovieDB);

// switch - не можем использовать т.к. он используется для прямого сравнения (=10, =30)


// -----------Урок 16 ------------------------------------
// Функции и стрелочные функции

/*
 Функции - это наши действия в JavaScriptе: они используют различные типы данных,
 изменяют информацию так, как мы укажем, значительно сокращают код, как циклы.
 Можно представить функцию как калькулятор.
*/
// (аргументы), {действия}

// let num = 20;

// function showFirstMessage(text) {
//     console.log(text);
//     // let num = 10; 
//     console.log(num);          // изменили(переопределили) переменную (было num=10)
//  }
//  showFirstMessage("Hello World");
//  console.log(num);        //чтобы функция заработала надо ее вызвать
 /*
 одно из главных вещей функции - ее имя
  оно должно быть глаголом с припиской того, над чем выполняется действие
 (например: showFirstMessage - показать первое сообщение ).
 Есть анонимные функции(без имени) - они вызываются и используются здесь и сейчас
 только один раз.
 аргументы записываются в (), когда функция вызывается, можем дать какие-то данные
 которые она будет использовать внутри себя
 При использовании аргумента (text) VSCode подсвечиваеn,  что этот аргумент используется.
 Теперь чтобы функция отработала, аргумент надо передать в showFirstMessage("Hello World");
 Когда функция запустится, она возьмет строку которую мы ей передали"Hello World",
  подставит вместо text в function showFirstMessage(text), и засунет вместо text в
  console.log(text)
  Аргументов может быть бесконечное количество(чтобы записать еще аргумент ставим запятую).
  Если переменная создана внутри функции (в {} скобках) она называется локальной и
  видна только в области видимости
  Если переменную вывести из фигурных скобок и переместить перед функцией она станет
  глобальной т.е. функция будет использовать глобальную переменную (часто используемый
  прием)
  Если в функции запишем let num = 10 то при выполнении кода в консоли выйдет 20 -
  т.к.  let num = 20 это глобальная переменная, которая видна везде.

  Что такое замыкание
  Когда функция вызывается, то по факту она пытается найти  переменные, значения
  внутри себя(функции) и если не находит, то она переходит на уровень выше, до самого
  высшего уровня, который ей вообще доступен.

//   Замыкание функции - это сама функция вместе со всеми внешними переменными, 
                        которые ей доступны

 Кроме всех действий функция может вернуть какое-либо значение при помощи ключевого
 слова return. Как только функция увидит return - она прекратит свое действие
 */

//  function calc(a, b) {      // Это значит когда запустится функция calc 
//      return (a+b);          // она вернет сумму а и в аргументов
//    //console.log("dwed")    // после return код никогда не выполнится
//                             //  после return ничего не задаем
//  }
//  // Теперь эту функцию можем переиспользовать много раз
//  // Функция это один из принципов оптимизации кода

//  console.log(calc(4, 3));
//  console.log(calc(5, 6));
//  console.log(calc(10, 6));  
//  // каждый раз используем функцию с различными аргументами 
//  // в этом заключается суть функции - автоматизации процессов

//  // У return есть еще одно применение не только окончание функции, но и возвращение
//  // значения наружу:
//  // на практике эт часто используется

//  function ret() {
//      let num = 50;

//     // здесь может выполняться огромный код (например:логика работы с зарплатами, какими-то данными и.т.д.)

//      return num;
// // функция возвращает значение локальной переменной num
// // т.е. возвращается результат работы функции
//  }
// //  и его мы можем куда-то записать:
// // в переменную anotherNum помещаем результат работы функции ret();
// const anotherNum = ret();
// // и чтобы проверить
// console.log(anotherNum);
// // Получаем 50, потому что 50 вышла наружу const anotherNum = ret();

// // Классификация функций ---------------------------------

// // 1 Function Declaration

// function foo() {
//     // код
// }               // при Function Declaration точку с запятой (;) не ставим

// Она существует еще до того, как наш код запустится
//(например: как переменная var - она существует до того, когда ее объявили, 
// тоже самое и с функцией)
// Создается до начала выполнения скрипта, можно вызвать перед объявлением
/*
Как это работает: Когда html-страница загружается попорядку, доходит до скрипта -
скрипт начинает загружаться. Первым делом браузер пробегается по скрипту и 
находит все переменные var(если они там есть) и все Function Declaration.
Он их создает, он их объявляет и после этого код начинает выполняться,
и все опять идет по порядку(сверху вниз)

 Преимущества этого подхода: если функция существует до того как она объявлена,
 то мы можем например: фукцию calc можем использовать таким образом:

 console.log(calc(4, 3));
 console.log(calc(5, 6));
 console.log(calc(10, 6)); 

 function calc(a, b) { 
    return (a+b);          
 }
    и это не вызовет никаких ошибок, т.е. функция работает до того как она была вызвана
Иногда разработчики прием используют: что все функции которые созданы в одном из файлов
они помещают в самый низ страницы, а сверху только используют.
*/

// 2 Function Expression

// Главное отличие от Function Declaration:
// Создается только тогда, когда доходит поток кода, 
// можно вызвать только после объявления 

// Это функциональное выражение
// Сперва должны создать переменнную и вовнутрь поместить функцию.

// let food = function() {
//     // код
//     console.log("Good");
// };          // при Function Expression точка с запятой (;) обязательна,
            // т.к. это переменная и значение функции ее внутреннее состояние

//Например:

// const logger = function() {
//     console.log("Hello");
// };
//     logger();       // вызов функционального выражения





// 3 Стрелочные функции-------------------------------
// Современный стандарт ES6 в 2015 году.

// () =>

// Не имеет своего контекста вызова

// Пример:
// const calc = (a, b) => a + b;
// создаем переменную, в которую помещаем функцию (функция стрелочная)
// => указывает на выполнения кода

// В классическом варианте
// const calc = (a, b) => { return a+b};
// Позволяет значительно сократить код, чтобы использовать надо знать ее особенности
// 
// Главное не имеет своего контекста вызова, поэтому чаще всего встречается в обработчиках событий
// Если функция в одну строчку то можно без фигурных скобок
// Если функция содержит один аргумент:
// const calc = a => a + b;
// Если функция разрастается {} раскрываются и внутри производятся определенные действия
// const calc = (a, b) => {
//     console.log('1');
//     return a + b;
// }

// ----------Урок 17--------------------------------------

// ----- СТРОКИ----------------------------------

// Методы и свойства строк и чисел

// Методы - это вспомогательные функции
// Свойства - это вспомогательные значения

// такие же понятия встречаются в объектах

// Рассмотрим самые основные:

// const str = "test";

// console.log(str.length);
// получим 4 - количество символов в строке (в слове test)

// часто используемое свойство чтобы получить как длину строки, так и других данных
// таких как количество элементов внутри массива, например:

// const arr = [1, 2, 4];

//  console.log(arr.length);
 // Получим 3 - кол-во элементов в массиве
 // Когда используем свойство (например: lendth), мы его не вызываем, а
 // пишем через точку(.length)
 // методы пишутся с () в конце
 // Получение сведений о методах и свойствах string в браузере:
 // console.dir(Number) -  выводит элемент в виде объекта(методы, свойства)

 // Использование в консоли браузере console.dir: можно посмотреть различные свойства,
 // методы и как использовать.

 // Как использовать:

 // Попробуем получить часть строки через индекс
//  const str = "test";
//  const arr = [1, 2, 4];

//  console.log(str[2]);
 // получим: s

//  const str = "test";
//  const arr = [1, 2, 4];

//  console.log(str[2] = 'd'); // ошибка: если поменять символ s на d - не получится:
 // когда строка записана так "test" на прямую изменить не можем - для этого есть другие методы:

 // Изменение регистра

//  const str = "test";

//  console.log(str.toUpperCase());  //(.toUpperCase() - метод)т.е. выполняем действие над сторокой
//  console.log(str);
 /*
в консоли видим что test превратился в TEST(верхние регистр), но предыдущее значение 
в str не поменялось, это означает что кусок кода str.toUpperCase() возвращает
новое значение, оно напрямую не изменяет строку которое было в исходных данных, а 
новое значение мы можем использовать в дальнейшем: в console.log или записать в
другую переменную и т.д.
*/

// тоже самое будет и с toLowerCase(превращает в нижний регистр):
// const str = "teSt";

// console.log(str.toLowerCase());  //(.toUpperCase() - метод)т.е. выполняем действие над сторокой
// console.log(str);
// применяется для превращение строки в единый формат( в примере - нижний регистр,
// при опечатке польз-я)
// Очень часто используются

// Метод который позволяет найти кусок строки и сказать с  какого индекса, с какой 
// позиции она начинается. В официальной документации программирования 
// называется: Поиск подстроки
// Пример:

// const fruit = "Some fruit";

// console.log(fruit.indexOf("fruit"));
// .indexOf - тоже метод и должен принимать в себя какой-то аргумент,
// Попытаемся найти кусок строки и найти с какого индекса начинается
// например мы хотим найти "fruit" - в консоли получится 5 т.к. в строке
// "Some fruit" - перед fruit - 4 буквы и 1 пробел
// Такой метод используется и для того чтобы определить, а действительно 
// ли в этой строке есть искомое значение

// const fruit = "Some fruit";

// console.log(fruit.indexOf("q"));
// Здесь покажет -1 - т.е. это не было найдено

// Вопрос: Если строка не изменяема, то какже мы можем ее модифицировать или 
// ее как-то поменять?

// Будем разбирать методы, которые взаимодействуют со строками
// Всего их JavaScript - 3(три)

// 1 Метод .slice (слайс)

// const logg = "Hello world";
// // чтобы модифицировать эту строку воспользуемся методом slice (слайс)
// // и говорим что мы  хотим вернуть из этой строки
// console.log(logg.slice(6, 10));
// Синтаксис () - задаем 2 аргумента( 2 значения (start и end)): 
// 1 говорит - с какой части строки необходимо возвращать что-то (6)
// Задача: отрезать world  и как-то использовать 
// 2 - где нам заканчивать непосредственно это вырезание куска строки (10)
//  В консоли получится: worl (обрежется последняя буква)
// Потому что когда используем  slice, в аргументе end( во втором аргументе(10))
// указываем то, что не включается т.е. до какого-то момента, но не включая его
// Есть еще одно использование метода slice - можно указать только один аргумент
// т.е. с чего начинать - это значит строка будет вырезаться просто до конца
// Эти методы очень часто используются
// slice поддерживает и отрицательные значения, например:
// const logg = "Hello world";

// console.log(logg.slice(-5, -1));
// Получим worl(отсчет с конца строки) - применяется редко

// 2 Метод .substring (субстринг)

// const logg = "Hello world";

// console.log(logg.substring());
// также 2 аргумента: start и end

// Отличие .substring от .slice:
// разница в том что 1 аргумент можно задать больше чем 2 аргумент(не стоит так делать)
// и .substring - не поддерживает отрицательные значения
//(если будет -6 - будет интерпретироваться как ноль(0))

// 3 метод substr

// const logg = "Hello world";

// console.log(logg.substr(6, 5));
// Главное отличие: вместо 2 аргумента(end) указываем длину, сколько символов
// необходимо вырезать
// получим: world 

// --------ЧИСЛА ----------------------------------

//В JavaScript есть мини библиотека, которая существует внутри браузера, внутри 
// JavaScript - Math. В котором много математеческих свойства и методы
// Пример: Округление 
// Округление к ближайшему целому числу

// const num = 12.2;
// console.log(Math.round(num));

// parseInt() - переводит число в другую форму исчисления

// const test = "12.2px";
// console.log(parseInt(test));
// получим 12 и это числовой тип данных, когда строка переводится в число
// когда строка обрезается и остается целое число
// часто используется

// parseFloat() - используется для перевода(число или строку) в десятичном варианте

// const test = "12.2px";
// console.log(parseFloat(test));
// получим 12.2


//-------------Урок 18-----------------------------------------
// Практика, ч3. Использование функций
//-------------Урок 18-----------------------------------------
// Практика, ч3. Использование функций 

// 1) Первую часть задания повторить по уроку

// 2) Создать функцию showMyDB, которая будет проверять свойство privat. Если стоит в позиции
// false - выводит в консоль главный объект программы

// 3) Создать функцию writeYourGenres в которой пользователь будет 3 раза отвечать на вопрос 
// "Ваш любимый жанр под номером ${номер по порядку}". Каждый ответ записывается в массив данных
// genres

// P.S. Функции вызывать не обязательно*/



// Код возьмите из предыдущего домашнего задания

// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');
// // 1) Первую часть задания повторить по уроку

// function start() {

// }
// в функцию помещаем действие (const numberOfFilms = 
// +prompt('Сколько фильмов вы уже посмотрели?','');) и добавим проверку:
// чтобы пользователь не отменил, не ввел пустую строку, и ввел нечисло
// проверять будем на этапе выполнения(когда пользователь нажал кнопку ОК),
// но если хотим проверить на этапе ввода(когда пользователь печатает в input)
// надо использовать регулярные выражения( будет ниже )

// Если мы будем использовать personalMovieDB(базу данных) внутри функции start() как 
// глобальную переменную, то она превратится в локальную(внутри переменной) и мы
// не сможем ее записать в (const personalMovieDB = {       
//    count: numberOfFilms)
//     --//--
//}     // можно обойти при помощи return
// Сделаем по другому
// const personalMovieDB = {       // наша база данных - идет как глобальная переменная
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// 1 задание----------------------------------------

// let numberOfFilms;  // меняем const на let(т.к. будем менять содержание константы)
// // теперь она переменная объявленная глобально

// function start() {
//     numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');

// // Здесь будут проверки другим циклом while ( пока чтото у нас происходит или не происходит? 
// //то будем выполнять какие-то действия)
//     while(numberOfFilms == '' || numberOfFilms == null || isNaN(numberOfFilms)) { 
// // проверка на пустую строку(=='') или пользователь отменяет действие (== null) или
// // пользователь ввел не число(isNaN(numberOfFilms))(проверяет если внутри не число,
// // то он возвращает правду т.е. если введет буквы то это будет не число)
// // Когда мы создали такую проверку:
// // цикл будет выполняться пока одно из этих условий будет правдивым( т.е. пустая строка, 
// // нажатие кнопки "Отмена", или введено не число)
// // И повторяем вопрос пользователю
//         numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?','');
//     }    
// }
// // после этого вызываем функцию start
// start();

// const personalMovieDB = {       // наша база данных - идет как глобальная переменная
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// // здесь мы проверяли при помощи цикла(for(let i = 0; i < 2; i++) и условиями 
// // if и else внутри


// // Это цикл(for(let i = 0; i < 2; i++)) будем вызывать по требованию
// // т.е. создать функцию которая будет ее оборачивать

// function rememberMyFilms() {    // запомнить те фильмы, которые сюда приходили
// // и вырезать весь цикл (for(let i = 0; i < 2; i++)) и поместить внуть этой функции
    
//     for(let i = 0; i < 2; i++) {     // задаем начальные условия (цикл настроен)
//         // надо вписать действия, которые будут происходить каждый раз, когда он повторяется
//         const a = prompt('Один из последних просмотренных фильмов?', ''),
//                 b = prompt('На сколько оцените его?', '');
        
//         if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//             personalMovieDB.movies[a] = b;
//             console.log('done');
//         } else{
//             console.log('error');
//             i--;
//         }
//     }
// }
// // и не забываем ее вызвать
// // rememberMyFilms(); 
// // т.е. функция вызовется и внутри сработает цикл


// // Обворачиваем и следующие условия(if (personalMovieDB.count < 10) { ) 
// // (помещяем во внутрь функции function detectedPersonalLevel() { )

// function detectedPersonalLevel() {
//     if (personalMovieDB.count < 10) {
//         console.log("Просмотрено довольно мало фильмов");
//     } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
//         console.log("Вы классический зритель");
//     } else if (personalMovieDB.count >= 30) {
//         console.log("Вы киноман");
//     } else {
//         console.log("Произошла ошибка");
//     }

// }
// // И вызываем функцию
// // detectedPersonalLevel();

// // Теперь есть функции которые занимаются определенными вещами и вызываются
// // когда необходимы

// // 2 задание -----------------------------------

// function showMyDB(hidden) {
// // тут проверяем условие
//     if (!hidden) {                      // если наша база данных не скрыта,
//         console.log(personalMovieDB);   // то мы ее показываем
//     }
// }
// // т.к. в нашей базе данных (const personalMovieDB = { ) 
// // privat: false, то в функции (function showMyDB(hidden) { )
// // в условии (if (!hidden) { ) (! - отрицание), то false - превращается в true 
// // функция готова и вызываем ее:

// showMyDB(personalMovieDB.privat);
// // при вызове функции в качестве аргумента в() передаем кусочек базы данных
// // если без аргумента ничего страшного нет - это тоже правильный подход

// // теперь протестируем
// // для этого функции закомментируем
// // проверим при данных privat: false - база данных 
// // в консоли показана
// // проверим при privat: true - база данных не видна


// // 3 задание--------------------------

// // function writeYourGenres() {
// //     // здесь будем три раза задавать вопрос и создаем цикл
// //     // и начнем с 1, т.к. пользователь не знает что в программировании начинается с 0.(i = 1;)
// //     // цикл повторяется 3 раза (i <= 3)

// //     for (let i = 1; i <= 3; i++) {
// //         // далее задаем пользователю вопрос
// //         // меняем на бектики(``) и в {} вставляем i
// //         const genre = prompt(`Ваш любимый жанр под номером ${i}`);
// //         // вторая часть задания записать в базу данных ответ пользователя
// //         // когда записываем в базу данных то должны начинать с 0(ноля) [i -1].
// //         personalMovieDB.genres[i - 1] = genre;
// //     }
// // }
// // так же функцию можно записать по другому: результат такой же

// function writeYourGenres() {
//     for (let i = 1; i <= 3; i++) {
//         personalMovieDB.genres[i - 1] = prompt(`Ваш любимый жанр под номером ${i}`);
//     }
// }
// // вызываем функцию
// writeYourGenres();

// ------------Урок 19---------------------------------
// Callback - функции

// Callback - функции - это функция которая должна быть выполнена, после того
// другая функция завершила свое выполнение (часто применяется)

// function first() {
//     // Do something (Сделай что-нибудь)
//     //Данная функция имеет какую-то задержку: задержка (функция может общаться с сервером,
//     // и сервер ответит через полсекунды или обработка данных, которые требуют времени
//     // сэмулируем такое поведение с помощью конструкции, которая делает определенную
//     // задержку в нашем коде: получится задержка в полсекунды(500 миллисекунд)
//     setTimeout(function() {
//         console.log(1);
//     }, 500); 
//     // через полсекунды в консоль выведется 1
// }

// function second() {
//     console.log(2);
// }
// // не забываем вызвать функции
// first();
// second();
// получаем сперва 2 потом 1, то есть 2 функция сработала раньше из-за задержки в 500мс
// но если смотреть на код не все становится очевидным, т.к. функции при вызове 
// должны строго выполниться одна за другой и поэтому можем получить непредсказуемый 
// результат, особенно важно когда эти функции работают с одними и теми же данными
// Запомнить: если функции идут одна за другой, это не значит что они выполняются
// так же.

// Callback - функции - это функция которая должна быть выполнена, после того
// другая функция завершила свое выполнение (часто применяется)

// Пример функции:
// function learnJS(lang, callback) {      // главный шаблон callback-функции
// // в lang- передадим 1 аргумент(какойто-то язык)
// // в Calback - то что в другую функцию в качестве аргумента в будущем мы сможем
// // передать другую функцию
//     console.log(`Я учу: ${lang}`);
// // и дальше чтобы вызвать callback-функцию, которая тоже будет передана как аргумент
// // берем ее и вызываем:
//     callback();
// // т.е. когда выполнится первое действие от первой функции (console.log(`Я учу: ${lang}`);)
// // выполнится вторая функция (callback();)
// }
// function learnJS(lang, callback) {  
//     console.log(`Я учу: ${lang}`);
//     callback();
// }
// learnJS('JavaScript', function(){
//     console.log('Я прошел этот урок');
// });
// // таким образом должна соблюдаться последовательность функций(часто применяемый прием)
// // function(){} - анонимная функция(без аргументов)- вместо нее можно передать
// // осознанную функцию - 

// // Пример вместо предыдущей функции (вместо анонимной функции
// // передадим (function done() {} )) :

// function learnJS(lang, callback) {  
//     console.log(`Я учу: ${lang}`);
//     callback();
// }

// function done() {
//     console.log('Я прошел этот урок');
// }

// learnJS('JavaScript', done);

// Один из важных моментов это то как передаем эту функцию,
// без скобок (done()) т.к. передали только функцию
// мы сказали: функция learnJS выполни функцию done тогда, когда дойдешь до callback()
// done как функция передается вместо callback и внутри function learnJS(lang, callback) { 
// и когда нужно вызывается и поэтому в learnJS('JavaScript', done); не ставим () скобки
// Потому что мы не вызываем функцию, а передаем чтобы в дальнейшем была использована.

// Если говорить о практике, то мы будем использовать callback постоянно при запросах 
// к серверу либо если в серверном программировании на node.js? где почти все построено 
// на таких callback-ах
// На следующих уроках будем работать с событиями, которые происходят на странице
// Например: когда пользователь только кликнул на странице(т.е. первый аргумент),
// только после этого передаем callback-функцию которая выполняется строго после клика.
// Т.к. JavaScript весь построен на интерактиве мы постоянно будем ловить действия
// пользователя и после них, при помощи таких коллбэков выполнять определенные действия.

// Итоги:
// callback-и позволяют нам быть уверенными в том, что определенный код не начнет исполнение
// до того момента, пока другой код не завершит свое исполнение


// ------Урок 20--------------------------------------
// Объекты, дестуктуризация объектов(ES6)


// Будем использовать методы объектов
// Создать объект можно через фигурные скобки или другим способом.

// (const obj = new Object();) - лучше через {} скобки

// const options = {
//     name: 'test',                       // ключ-значение
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'                               // разные типы данных(объект)
//     }
// };
// если надо достучаться до из свойств: можем воспользоваться синтаксисом
// при помощи точки или квадратных скобок []
// Пример:
// console.log(options["colors"] ["border"]);
// получим black - т.е. добрались до значения ключа border который находится
// в объекте colors( т.е. обращаемся сразу к 2 ключам в[] скобках)

// console.log(options.name);      // получим test
// если нам необходимо удалить какое-то свойство(пару ключ-значение) из объекта
// здесь понадобиться другой оператор: delete

// delete options.name;
// console.log(options);   // в объекте будет отсутствовать name:test

// если надо будет удалить сразу много свойств из очень большого объекта
// можно запустить цикл, который будет ориентироваться на какие-то параметры
// и удалять определенные свойства из объекта.
// мы работаем с const(константой), но объект который находится внутри 
// можем модифицировать(изменять)( прямых констант в JS не существует)
//(объект это шкаф, в котором находятся вещи, коробки в которых находятся 
// другие вещи и тому подобное)

// Чтобы перебрать все свойства объекта(как в шкафу: что завалялось,
// и что можно с ними сделать) есть конструкция: for..in

// пишем for в скобках( настраиваем цикл: укажем в каком объекте перебирать
// свойства и как это каждое свойство назвать(т.к. изначально не знать как
// назывется каждое свойство) мы должны обозначить их общим словом)

// for (let key in options) {  // задаем переменную key и будем копаться в options
// действия цикла, который будет работать столько, сколько есть свойств внутри
// этого объекта.
// в (`т.к. перебираем каждое отдельное свойство ${key}` и хотим указать, что
//  за значение ${options[key]} находится внутри свойства ${key}` )
//     console.log(`Свойство ${key} имеет значение ${options[key]}`);
// }
// цикл сработал и вывел все пары ключ-значение
// (есть еще цикл for..off - для объекта работать не будет)
// в консоли ответы: строчный тип данных
// если попадается вложенный объект в объекте JS не может объект превратить 
// в строку и в консоли выводит такую структуру - object(это строковое представление
// объекта)
// для перебора можно использовать рекурсию(которая больше подходит для функций).
// Разберем такую конструкцию: когда перебираем все эти ключи мы их также
// можем внутри проверять при помощи условий, если значение ключа, который мы 
// перебираем будет объектом, мы можем запустить перебор внутри перебора
// (тоже допустимо), и все должно правильно отработать:

// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);            
//         } 
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//     }
// }
// В консоли получим: 
// Свойство name имеет значение test
// Свойство width имеет значение 1024
// Свойство height имеет значение 1024
// Свойство border имеет значение black
// Свойство bg имеет значение red

// Уобъектов нет свойства length(длина) - т.е. мы не можем узнать количество
// пар ключ-значение внутри объекта
// Самый простой способ- взять и перебрать все свойства внутри объекта
// и создать какую-то переменную, которая будет счетчиком
// Пример счетчика (часто применяется):

// const options = {
//     name: 'test',                       // ключ-значение
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'                               // разные типы данных(объект)
//     }
// };

// let counter = 0;    // создадим переменную-счетчик

// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//          // counter++;  // это надо удалить,если хотим узнать только на верхнем уровне           
//         } 
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         counter++;
//     }
// }
// console.log(counter); // получим 5- всего свойств в объекте

// классический метод узнать кол-во свойств в объекте выглядит так:
// просто запускаем перебор и увеличиваем counter++(переменная -счетчик)
// const options = {
//     name: 'test',                       // ключ-значение
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'                               // разные типы данных(объект)
//     }
// };

// let counter = 0;    // создадим переменную-счетчик

// for (let key in options) {
//     // if (typeof(options[key]) === 'object') {
//     //     for (let i in options[key]) {
//     //         console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//     //      // counter++;  // это надо удалить,если хотим узнать только на верхнем уровне           
//     //     } 
//     // } else {
//     //     console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         counter++;
//     // }
// }
// console.log(counter); // получим 4 - кол-во свойств на верхнем уровне

// Просто чтобы пересчитать свойства объекта, приходится каждый раз создавать переменную,
// каждый раз увеличивать, для этого запускать метод перебора и это неудобно.

// Переходим к методам которые часто используются у объектов
// Object keys (ключи нашего объекта)

// const options = {
//     name: 'test',                       // ключ-значение
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'                               // разные типы данных(объект)
//     },
//     makeTest: function() {      // создали метод который будает работать внутри 
//         console.log("test");    // объекта options, похож на метод Object.keys(встроенный),
//     }                           // но созданный самостоятельно
// };

// options.makeTest();         // запускаем метод makeTest

// console.log(Object.keys(options).length);  //получим [массив с ключами]
// Object.keys(options) - дает нам массив, а .length- количество элементов
// этот метод берет наш объект и его основании создает массив, в котором все элементы
// это ключи(находящиеся впереди у пары ключ-значение)
// у строк и массивов есть такое свойство - length? чтобы узнать количество элементов
// Этот метод - Object keys - очень часто встречается и помогает.

// МЕТОДЫ - ЭТО ДЕЙСТВИЯ, КОТОРЫЕ УМЕЕТ СОВЕРШАТЬ НАШ ОБЪЕКТ
// ОБЪЕКТЫ ЭТО СТРУКТУРЫ КОТОРЫК МОГУТ СОХРАНЯТЬ В СЕБЕ ЛЮБЫЕ ТИПЫ ДАННЫХ В
// ФОРМАТЕ - КЛЮЧ-ЗНАЧЕНИЕ(ТАКЖЕ ВЛОЖЕННЫЕ ОБЪЕКТЫ В ОБЪЕКТЫ, МАССИВЫ В ОБЪЕКТЫ)
// Чтобы их перебрать мы можем использовать конструкцию:
// 1) for..in  - for (let i in options[key]) {
// 2) через точку или [] - console.log(options["colors"] ["border"]);
// 3) у объектов есть встроенные методы - console.log(Object.keys(options).length)
// 4) Можно во внутрь объекта записать функцию -makeTest: function() {  console.log("test");

// Также есть свойства акцессоры (get и set)

//----------Дестуктуризация объектов---------------
// -------------ES 6-------------------------------

// Когда надо достучаться до вложенных свойств(второй уровень)

// Дестуктуризация - будем вытаскивать вложенные переменные в качестве отдельных структур
// за наш объект и как-то использовать(разделить на части):

// const options = {
//     name: 'test',                       // ключ-значение
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'                               // разные типы данных(объект)
//     },
//     makeTest: function() {      // создали метод который будает работать внутри 
//         console.log("test");    // объекта options, похож на метод Object.keys(встроенный),
//     }                           // но созданный самостоятельно
// };

// options.makeTest();

// const {border, bg} = options.colors;   // в {} поместим вложенные свойства, после = ту 
// console.log(border);                   // структуру откуда хотим вытащить    

// Как устроен JavaScript изнутри:
// Все что есть в языке так или иначе идет от объектов,
// например используем метод tyUppercase на строке при переводе в верхний регистр
// откуда берется метод у строки, который умеет что-то делать?
// Строка на базовом уровне является объектом и получает этод метод через
// цепочку прототипов.
// В консоли браузера набираем console.dir(String) запускаем(нажимаем энтер)
// открываем String - тут у него есть методы и свойства, и есть свойство prototype
// JavaScript - является объектно-ориентированным языком и все сущности которые в
// нем есть сводятся к объектам(или прототипно-ориентированным)


// ---------Урок 21------------------------------------
// ---------Массивы и псевдомассивы--------------------
// Основныы методы работы с массивами

// Массив - содержит элементы по порядку с соотверствующей нумерациец по порядку

// const arr = [1, 2, 3, 6, 8];
// часто приходится редактировать массив(добасить, удалить)

// методы для работы с концом и началом массива ----------------------
// метод .pop - удаляет последний элемент массива
// arr.pop();   // получим [ 1, 2, 3, 6 ]

//  // метод push - добавляет элемент в конец массива
// arr.push(10);   // в (10) - какой элемент добавить -получим [ 1, 2, 3, 6, 8, 10 ]
// console.log(arr);

// методы добавления элемента в начале массива(shift и unshift)
// у этих методов есть недостаток:
// если вставляем элемент в начале массива, то меняется порядок нумерации
// и необходимо поменять их индекс(нумерации по порядку)
// это может занимать много времени и поэтому редко применяются

// метод перебора массива -------------------------
// const arr = [2, 3, 6, 8, 10];

// 1)

// for (let i = 0; i < arr.length; i++) {  //будет перебирать пока не кончится массив i < arr.length;
//     console.log(arr[i]);
// }
// В консоли пишем 
// чтобы обратиться к определенному элементу массива необходимо поставить [] и 
// внутри указать индекс(i), т.к. изначально индекс 0 - обратимся к первому элементу
// затем i++ увеличиться на еденицу,

// Кроме обычного цикла, можем использовать конструкцию перебора for..of

// 2)

// for (let value of arr) {    // при помощи такой конструкции можем перебрать
//     console.log(value);     // элементы со страницы
// }     
// let value - переменная которая будет отображать каждые отдельный элемент внутри массива
// of arr - массив в котором будем работать
// Объекты нельзя переюрать при помощи for..of,
// for..of - работает только с массивами (массивоподобными сущностями)
// например - массив, строка, псевдомассивы, map и set

// Особенности .length
// В массиве элементы хранятся по порядку - при нарушении правил это выглядит так:
// const arr = [2, 3, 6, 8, 10];

// arr[99] = 0;        // добавляется 1 элемент с индексом 99

// console.log(arr.length);
// // получим 100(элементов), но это совершенно не верно, в нашем массиве 6 элементов
// // Здесь раскывается свойство length - состоит из последнего индекса(99) +1

// console.log(arr);   // Узнаем что находится в массиве arr
// получим - [ 2, 3, 6, 8, 10, <94 empty items>, 0 ]
// <94 empty items> - 94 пустые ячейки - это главное(грубое) нарушение
// т.к. элементы лежат не порядку

// Метод - forEach, который используется больше всего в коде
// позволяет гибко перебрать элементы массива

// 3)

// const arr = [2, 3, 6, 8, 10];
// arr.forEach(function(item, i, arr) {
//     console.log(`${i}: ${item} внутри массива ${arr}`);
// });

// Вспоминаем по callBack-функции
// этот метод .forEach() - это функция, которая принимает еще одну функцию-callBack-функцию
// (function() - эта функция будет выполняться каждый раз для каждого элемента массива
// может принимать в себя три аргумента:
// 1 аргумент - тот элемент который перебираем(2, 3, 6, 8, 10) (${item})
// в () зададим в качестве аргумента - item  (обозвать можно как угодно)
// пример: button-если будем перебирать кнопки)
// 2 аргумент - номер по порядку - i (${i})
// 3 аргумент - это ссылка на массив который мы перебираем (${arr})
// Это записали callBack-функцию- которая выполняется строго после 
// определенных действий
// т.е. сперва forEach, а затем callback-и
// Получим:
// 0: 2 внутри массива 2,3,6,8,10
// 1: 3 внутри массива 2,3,6,8,10
// 2: 6 внутри массива 2,3,6,8,10
// 3: 8 внутри массива 2,3,6,8,10
// 4: 10 внутри массива 2,3,6,8,10
// Применяется на практических занятиях:
// позволяет удобно манипулировать массивом данных, например элементами со страницы
// Сможем перебрать,и например каждой кнопке назначить дополнительный класс
// или взять отдельно текстовый элемент по определенному селектору и 
// модифицировать
// Когда можно использовать метод forEach а когда обычный цикл или перебор
// for..of?
// метод forEach - в подобных задачах(перебор массива?)
// метод for..of - есть один плюс - то что можно использовать ключевые слова:
// breack и continue(когда проходили циклы, когда надо остановить цикл или
// пропустить одно повторение)
// Когда запустим forEach - его нельзя остановить на каком-то этапе
// Кроме forEach - есть несколько перебирающих методов, 
// но они занимаются ТРАНСФОРМАЦИЕЙ массивов
// Метод .map - также как и forEach перебрать каждый элемент, но при этом
// его модифицируя - в конце он вернет новый массив, который будет уже
// сильно отличаться от старого(элементы будут модифицированы)
// Метод filter - отфильтровывает массив, по тому критерию который задаем например:
// оставить только четные числа или элементы тип данных который строка

// Разберем методы split, join и sort
// Задача: от пользователя или сервера получили большую строку( строковый тип данных)
// где через какой нибудь знак(запятую) записаны товары и превратить в массив,
// где товары будут лежать по порядку
// метод split - превращает строку в массив, s- разделитель

// const str = prompt("", "");  // это базовый синтаксис
// и на основании этой строки сформировать список товаров
// const products = str.split(", ");
// обращаемся к str(здесь лежит большая строка)
// в .split() - в скобках указываем через какой разделитель будут товары в строке
// (точка с запятой , запятая )
// console.log(products);      // получим массив

// Есть обратная операция из массива в строку
// Пример: взять список имен которые нас интересует и вывести на экран
// пользователю в качестве не массива , а строчки чтобы увидел строку людей
// console.log(products.join("; ")); 

// Метод сортировки sort
// const str = prompt("", ""); 
// const products = str.split(", ");
// products.sort();
// console.log(products.join("; "));
// особенность sort - сортирует элементы массива как строки

// const arr = [2, 13, 26, 8, 10];
// // arr.sort();
// arr.sort(compareNum);
// // console.log(arr);
// // получим [ 10, 13, 2, 26, 8 ] - т.е. сперва идет число кот. начинается с 1
// // т.к. это строка, но это можно избежать:
// // метод sort может во внутрь принимать callback-функцию в arr.sort() 
// // можем сказать как именно сортировать массив, запишем шаблон
// // в эту функцию будут приходить 2 аргумента a и b (числа которые сравниваются )
// function compareNum(a, b) {
//     return a - b;
// }
// если такую callback- функцию передадим в arr.sort(compareNum);
// мы ее не вызываем а только передаем( как название), то числа должны
// отсортироваться правильно(по порядку)
// получим [ 2, 8, 10, 13, 26 ]
// как работает (function compareNum(a, b) {) : дело в том что метод sort
// внутри себя использует один из алгоритмов - алгоритм быстрой сортировки.
// шаблон быстрой сортировки:----------------
// const arr = [2, 13, 26, 8, 10];
// arr.sort(compareNum);
// console.log(arr);
// function compareNum(a, b) {
//     return a - b;
// }
//-------------------------------

// Псевдомассивы --------------------
//(очень часто встречаются во фронтенде )
// когда работаем с элементами на странице, от будем получать псевдомассивы
// Это такой объект, структура которого совпадает со структурой массива
// выглядит точно также, при одном важном условии: у таких псевдомассивов
// нет никаких методов - это структура которая хранит данные по порядку


//----------Урок 22-------------------------
// Передача по ссылке или по значению, spread-оператор(ES6-ES9)
// let a = 5,
//     b = a;
//     b = b + 5;

//     console.log(b);
//     console.log(a);
// // получим 10 и 5

// // создаем объект
// const obj = {
//     a: 5,
//     b: 1
// };

// const copy = obj; //  Это ссылка 
// // т.е. в переменную copy кладется ссылка на существующий объект obj

// copy.a = 10;    // такой же объект как предыдущий,
//                 // берем переменную а, и помещает туда 10
//                 // была 5 стала 10
// // посмотрим что получилось
// console.log(copy);
// console.log(obj);
// получим:
// { a: 10, b: 1 }
// { a: 10, b: 1 }
// хотя по идее мы создали копию obj(const copy = obj;) и
// модифицировали копию(copy.a = 10;), а не obj
// И видим что изменяя что-то внутри копии, мы модифицировали
// изначальный объект, т.е. конструкция (copy.a = 10;) не сработала
// или сработала неправильно
// Если работаем с примитивными типами данных(строки, числа,
// логические значения), то они передаются по значению
//(когда прописываем такую структуру b = a; работя с примитивными
//типами данных переменная а заменяется на 5(b = 5;) это работает
// только с примитивами)
// Если же работаем с объектами, то здесь идет передача уже 
// не по значению, а по ссылке

// Модифицируя копию (copy.a = 10;), мы модифицируем изначальный
// объект, потому что работаем не копией объекта, а ссылкой
// на предыдущую структуру (obj) - это называется
// ПЕРЕДАЧА ПО ССЫЛКЕ

// Как создавать копии объектов, массивов?
// Есть несколько способов:

// 1) Использование цикла----------------------

// функция будет принимать один аргумент (mainObj)
// который будем передавать объект(obj)
// Эта функция будет заниматься тем, что при помощи цикла
// она создаст новый объект, уже перебирая старые свойства
// которые были в нашем объекте
// function copy(mainObj) {
//     let objCopy = {};    // создаем копию, для создания нового объекта ставим{}

// создаем перебирающую конструкцию for..in
//     let key; // можно создавать вне перебирающей конструкции

//     for (key in mainObj) {
//         objCopy[key] = mainObj[key];
//     }
//     return objCopy;
// }
//  есть ключи (key) внутри объекта (mainObj) который передается
// в функцию(сразу подсветился),  и вовнутрь помещаем
// копирование свойств(objCopy) внутри которого создаем
// новое свойство через [](такое же обозначение как и в главном объекте
// key) и дальше делаем копию из главного объекта(mainObj[key])

// по простому - пройдемся по старому объекту(mainObj[key]) скопируем
// все свойства, которые там есть и поместим все 
// в новую копию(objCopy[key]), которыя была изначально пустой
// objCopy = {}

// Тестирование этой функции:
// создадим переменную numbers - это будет объект
// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };
// скопируем объект
// воспользуемся функцией copy, она примет в себя  numbers
// и вернет новый объект, который будет уже копией 
// const newNumbers = copy(numbers);   // создали копию(клонировали)
//чтобы убедиться
// newNumbers.a = 10;
// newNumbers.c.x = 10; // попробуем поменять х внутри объекта с:

// console.log(newNumbers);
// console.log(numbers);
// получим 2 разных объекта
// { a: 10, b: 5, c: { x: 7, y: 4 } } - копия с изменненым а: 10
// { a: 2, b: 5, c: { x: 7, y: 4 } } - копия старого объекта
// Это значит копия готова

// при замене х внутри объекта с: получилось:
// { a: 10, b: 5, c: { x: 10, y: 4 } }
// { a: 2, b: 5, c: { x: 10, y: 4 } }
// т.е. х: 10 поменялось в старом и новом объекте
// это поверхностная копия объекта
// Когда клонируем объекты(копируем) есть 2 важных понятия:
// глубокие и поверхностные копии объектов

// 2) Object.assigh  ------------------

// позволяет объеденить несколько объектов
// const add = {
//     d: 17,
//     e: 20
// };
// будем объединять объект add и объект numbers
// console.log(Object.assign(numbers, add));
// в () первый аргумент поместим объект в который хотим поместить
// второй аргумент - объект который собираемся помещать
// получилось:
// { a: 2, b: 5, c: { x: 10, y: 4 }, d: 17, e: 20 }
// два объекта просто соединились
// создали независимую поверхностную копию объекта, которая
// не зависит не от newNumbers и не от add
// Тоже самое можем сделать и с пустым объектом, чтобы сохдать
// просто копию объекта: помещаем пустой объект ({}) и
// помещается старый объект и получаем отдельную копию
// const clone = (Object.assign({}, add));

// clone.d = 20;

// console.log(add);

// console.log(clone);

// 3)Массивы(частный случай объекта)
 
// Чтобы создать копию массива метод .slice();
// который позволяет просто скопировать старый объект

// const oldArray = ['a', 'b', 'c'];
// в массивах чтобы создать поверхностную копию массива
// просто создаем новую переменную

// const newArray = oldArray; - если так оставим
// получится ссылка на массив


// получим 2 разных массива:
// [ 'a', 'hjhkk', 'c' ] - новый массив
//[ 'a', 'b', 'c' ] - старый массив


// 4) Создание поверхностной копии с использованием
// оператора "разворота" - spread-оператор(ES6-ES9) ------------
// (т.к. он разворачивает структуру и превращает его в просто
// набор каких-то данных)
// В новом стандарте ES6 - для массивов 
//                  ES8 - для объектов
// const video = ['youtube', 'vimeo', 'rutube'],
//       blogs = ['wordpress', 'livejournal', 'blogger'],
//       internet = [...video, ...blogs, 'vk', 'facebook'];  
// в переменной internet будем складировать все значения из
// массивов video и blogs
// Можно сделать при помощи цикла, поискать какой-нибудь метод,
// который уже есть, но лучше spread-оператор - 
// для этого вставляем в internet = [...video, ...blogs];
// и spread-оператор должен развернуть эту структуру на 
// отдельные значения для этого ставим троеточие перед переменной
// console.log(internet);
// получим:
// [
//     'youtube',
//     'vimeo',
//     'rutube',
//     'wordpress',
//     'livejournal',
//     'blogger',
//     'vk',
//     'facebook'
//   ]
// оператор разворота просто развернул эти структуры на отдельные
// элементы

// еще один пример посложнее:

// function log(a, b, c) {
//     console.log(a);
//     console.log(b);
//     console.log(c);
// }
// посмотрим как эти переменные будут выводится.
// мы предполагаем что такие данные туда придут.

// const num = [2, 5, 7];
// допустим что массив пришел от сервера, что он сформировался
// на стороннем ресурсе и пришел в таком виде. Представим что вместо
// этих цифр могут прийти данные о каком-то видео:
// например: 2 - ссылка на сам источник, 5 - ссылка на заглушку(картинку),
// 7 - ссылка на автора  и все 3 аргумента надо передать в function log.
// Как это сделать, ведь функция принимает 3 отдельных элемента - она 
// не принимает массив. Здесь поможет spread-оператор
// Мы запускаем эту функцию? но вовнутрь вместо того чтобы передать
// 3 аргумента ставим троеточие ...numbers
// log(...num);
// С такой конструкцией будем работать часто, особенно во второй части
// там где будем использовать библиотеку react

// 5) spread- оператор для объектов(поверхностная копия) -------------

// const array = ["a", "b"];
// чтобы сделать поверхностную копию нужно (...)
// const newAarray = [...array];
// теперь в переменной newAarray лежит новая копия массива array

// создадим объект
// const q = {
//     one: 1,
//     two: 2
// };
// все что необходимо будет для создания новой копии это
// использование spread-оператора
// const newObj = {...q};
// и чтобы поместить в этот объект newObj = {} все значения родительского
// объекта q = {} мы должны поставить троеточие в const newObj = {...}
// и написать название объекта {...q};(работает с ES9)
// Часть нововведений, которые появляются в javascript используются
// еще до того как были стандартизированы
// Запомнить: не важно к какому стандарту относится та или иная фича,
// главное чтобы умели использовать.


// -------Урок 23--------------------
// Основы ОПП, прототипно-ориентированное наследование(стиль ОПП)
// ОПП - объектно-ориентированное программирование(важное для 
// понимания javascript)
//  Смысл ОПП - заключается в том, что мы представляем любую вещь,
// как объект( с набором свойств и методов)
// Если работаем со строкой(свойства: длина строки, методы: изменение регистра,
// для модификации и т.д.)
// если строка написана окруженными кавычками "primer" - это обычный
// примитив, простой тип данных.
// Но как только пытаемся вызвать какой-то метод или свойство
// например "primerone".toLowerCase или какие-то другие методы, то
// javascript оборачивает строку в объект и после модификации уже
// возвращает строку на место, например

// let str = "some";
// let strObj = new String(str);

// console.log(typeof(str));
// console.log(typeof(strObj));
// получаем 
// string (строка)
// object(объект)
// так происходит когда в javascript пытаемся использовать какой-то
// метод на строке: (typeof(strObj)) - оборачивает строку в объект,
// потом использует какой-то метод, который есть у этого объекта
// и возвращает все обратно
// Сперва был примитивный тип данных -"some"; потом в работе превратился 
// в объект - new String(str), потом опять вернулся в примитив
// Как javascript знает что ему , как нужно делать?
// Когда создаем строки, массивы все они могут содержать разное наполнение,
// но они обладают одними и теми же методами. Неважно что находится в строке
// все равно можем использовать например метод toUppercase
// Когда создаем массив, мы создаем новый экземпляр прототипа массивов.

// console.dir([1, 2, 3]);
// в консоли браузере получим:
// Array(3)
// 0: 1
// 1: 2
// 2: 3
// length: 3
// __proto__: Array(0)
// Создали экземпляр массива, но весь прототип массива __proto__: Array(0)
// который дает нам возможность создавать такие структуры находится в 
// свойстве __proto__ : Раскроем, видим все методы которые могут 
// применяться к массивам и конце увидим опять __proto__: Object
// который ссылается на объект 
// Мы создали экземпляр массива - [1,2,3],дальше идет свойство __proto__
// и есть большой прототип что является массивом, он содержит методы
// которые мы можем использовать на каждом из экземпляров, дальше
//  по цепочке __proto__ и приходим к объекту - и убеждаемся что объект самая 
// главная структура. те методы которые нет в массиве, но они все равно откуда
// то беруться у экземпляров массивов, на самом деле приходят из объекта
// массивы могут брать свои свойства и методы и если необходимо на нижнем
// уровне могут переопределить.
// так что любые конструкции прототипно наследуются у объекта( по такой
// цепочке прототипов и работает).
// рассмотрим прототип числа, далее блок с числом,далее ведет к объекту

// Примеры:
// const soldier = {       // большой прототип описывает всех
//     health: 400,
//     armor: 100,
//     sayHello: function() {
//         console.log("Hello")
//     } 
// };
// const jonh = {          // отдельное описание конкретного
//     health: 100
// };
// Установить связь чтобы jonh чтобы он умел все что и soldier,
// чтобы у него были все свойства, но с учетом некоторой специфики,  
// его модифицированы, есть несколько способов:

// 1. устаревший формат(может встретиться)

// в реальный проектах не использовать
// jonh.__proto__ = soldier; // установили  прототипом jonh-а - soldier

// console.log(jonh);  // получим { health: 100 }
// console.log(jonh.armor);    // получим 100
// несмотря на то, что у объекта jonh 1 свойство, благодаря прототипам
// получил 2 свойство, которое было у его прототипа : т.е. все
// массивы могут брать некоторые свойства из своего прототипа(из объекта)
// Это очень помогает на реальных проектах, например когда мы можем 
// создать большой прототип модального окна, который изначально 
// по умолчанию содержит определенные свойства(ширина, высота, какой-то
// базовый функционал, то что при клике на крестик модальное окно
// закрывается и т.д.) И от этого прототипа можем создавать много
// разных модальных окон, которые будут немного отличаться( по ширине
// по высоте и т.д.)
// jonh.sayHello();     // получим Hello
// Если добавим в прототип sayHello: function() { } получим: Hello
// Т.е. он взял из своего прототипа данный метод и использует по своему
// назначению.

// 2. Вместо __proto__ используются: 
// Object.create - создает объект с определенным прототипом proto как [[Prototype]]
// Object.getPrototypeOf - получать прототип(возвращает из obj)
// Object.setPrototypeOf - устанавливает прототип( из obj в proto)
// Примеры:

// const soldier = {       // большой прототип описывает всех
//     health: 400,
//     armor: 100,
//     sayHello: function() {
//         console.log("Hello");
//     } 
// };
// const jonh = {          // отдельное описание конкретного
//     health: 100
// };

// Object.setPrototypeOf(jonh, soldier);    // аналогично записи jonh.__proto__ = soldier;

// в () 1 аргумент - объект, которому назначаем прототип
// 2 аргумент - объект, прототип которого устанавливаем
// jonh.sayHello();
// получим Hello. теперь сделали правильно, по современному
// мы установили прототип для джона (jonh) от soldier, если это 
// необходимо сделать в динамике(т.е. jonh уже существовал и просто
// установили для него прототип)
//  Обычно когда работаем с кодом, мы не создаем изначально объекты и 
// потом им назначаем прототипы, мы это делаем на этапе создания объекта
// Пример:

// const soldier = {       // большой прототип описывает всех
//     health: 400,
//     armor: 100,
//     sayHello: function() {
//         console.log("Hello");
//     } 
// };

// const jonh = Object.create(soldier);
// создаем новый объект, в () записываем прототип
// Как читается эта команда:
// мы создаем новый объект(const jonh), который прототипно будет
// наследоваться от (soldier).
// jonh.sayHello();
// Получим Hello(т.е. снова созданный jonh, который ничего не содержит,
//  но умеет все от const soldier {})

// Из всего стоит запомнить Object.create - для создания прототипных связей
// и .setPrototypeOf.  

// ОПП - это наука о том, как делать правильно архитектуру.
// Также javascript можно назвать прототипно-ориентированным языком,
// это частный случай ОПП, один из его таких стилей и в javascript
// все в принципе строится на прототипах.

//------- Практика, ч.4 --------------------------------
// Используем объекты

// Будем делать рефакторинг(переписывание кода под новые условия
// и новые задачи) нашего кода

/* Задание на урок:

1) У нас уже есть рабочее приложение, состоящее из отдельных функций. Представьте, что
перед вами стоит задача переписать его так, чтобы все функции стали методами объекта personalMovieDB
Такое случается в реальных продуктах при смене технологий или подхода к архитектуре программы

2) Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false - он
переключает его в true, если true - переключает в false. Протестировать вместе с showMyDB.

3) В методе writeYourGenres запретить пользователю нажать кнопку "отмена" или оставлять пустую строку. 
Если он это сделал - возвращать его к этому же вопросу. После того, как все жанры введены - 
при помощи метода forEach вывести в консоль сообщения в таком виде:
"Любимый жанр #(номер по порядку, начиная с 1) - это (название из массива)"*/


// Код возьмите из предыдущего домашнего задания

// let numberOfFilms;

// function start() {
//     numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

//     while(numberOfFilms == '' || numberOfFilms == null || isNaN(numberOfFilms)) {
//         numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');
//     }
// }

// start();

// const personalMovieDB = {
//         count: numberOfFilms,
//         movies: {},
//         actors: {},
//         genres: [],
//         privat: false
// };

// function rememberMyFilms() {    // запомнить те фильмы, которые сюда приходили
// // и вырезать весь цикл (for(let i = 0; i < 2; i++)) и поместить внуть этой функции
    
//     for(let i = 0; i < 2; i++) {     // задаем начальные условия (цикл настроен)
//         // надо вписать действия, которые будут происходить каждый раз, когда он повторяется
//         const a = prompt('Один из последних просмотренных фильмов?', ''),
//                 b = prompt('На сколько оцените его?', '');
        
//         if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//             personalMovieDB.movies[a] = b;
//             console.log('done');
//         } else{
//             console.log('error');
//             i--;
//         }
//     }
// }
// // и не забываем ее вызвать
// rememberMyFilms(); 

//------------------------------------------
/*
"use strict";
/* Задание на (4  практика) урок:

1) У нас уже есть рабочее приложение, состоящее из отдельных функций. Представьте, что
перед вами стоит задача переписать его так, чтобы все функции стали методами объекта personalMovieDB
Такое случается в реальных продуктах при смене технологий или подхода к архитектуре программы

2) Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false - он
переключает его в true, если true - переключает в false. Протестировать вместе с showMyDB.

3) В методе writeYourGenres запретить пользователю нажать кнопку "отмена" или оставлять пустую строку. 
Если он это сделал - возвращать его к этому же вопросу. После того, как все жанры введены - 
при помощи метода forEach вывести в консоль сообщения в таком виде:
"Любимый жанр #(номер по порядку, начиная с 1) - это (название из массива)"*/

// const personalMovieDB = {
//    count: 0,
//    movies: {},
//    actors: {},
//    genres: [],
//    privat: false,
//    start: function() {
//       personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
     
//       while(personalMovieDB.count == '' || personalMovieDB.count == null || isNaN(personalMovieDB.count)) {
//          personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
//       }
//    },
//    rememberMyFilms: function() {    
    
//       for(let i = 0; i < 2; i++) {     
//          const a = prompt('Один из последних просмотренных фильмов?', ''),
//                b = prompt('На сколько оцените его?', '');
           
//          if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//             personalMovieDB.movies[a] = b;
//             console.log('done');
//          } else{
//             console.log('error');
//             i--;
//          }
//       }
//    },
//    detectedPersonalLevel: function() {
//       if (personalMovieDB.count < 10) {
//          console.log("Просмотрено довольно мало фильмов");
//       } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
//          console.log("Вы классический зритель");
//       } else if (personalMovieDB.count >= 30) {
//          console.log("Вы киноман");
//       } else {
//          console.log("Произошла ошибка");
//       }
//    },
//    showMyDB: function(hidden) {
//       if (!hidden) {                      
//          console.log(personalMovieDB); 
//       }
//    },
//    toggleVisibleMyDB: function() {
//       if (personalMovieDB.privat) {
//          personalMovieDB.privat = false;
//       } else {
//          personalMovieDB.privat = true;
//       }
//    },
//    writeYourGenres: function() {
//       for (let i = 1; i <= 3; i++) {
//          personalMovieDB.genres[i - 1] = prompt(`Ваш любимый жанр под номером ${i}`);
//       }
//    }
// };

// ---------1 задание --------------------------------

// Объект (const personalMovieDB) существует
// Берем функцию (function start() {) делает ее методом и помещаем 
// в объект (const personalMovieDB) и правильно прописать
// т.е. запустить правильно синтаксис( start: function() {)
// важно чтобы все работало правильно(что это будет метод (start:)) и 
// что это будет функция(start: function() {) 
// (можно также использовать здесь стрелочную функцию (start: => {}))
// Что здесь меняется(будем менять)
// В методе мы работали с переменной numberOfFilms ( в start: function() {),
// т.к. этот метод уже внутри в базе данных(const personalMovieDB = {),
// то в переменной (let numberOfFilms;) нет нужды и ее удаляем.
// в count: 0 - записываем 0, т.е. фильмов у нас 0ж(удаляем numberOfFilms).
// А внутри метода (start: function() {) вместо всех (numberOfFilms)
// записываем (personalMovieDB.count)
// Т.е. когда запускаем метод start все правильно записывается в count
// и также задаем теже вопросы пользователю

// Вырезаем  rememberMyFilms() {} и вставим в базу данных(const personalMovieDB)
// не забываем менять синтаксис: rememberMyFilms: function() { 
// Все что осталось от вырезания удаляем.
// Также и со следующим методом: detectedPersonalLevel() { (вырезаем и вставляем)
// также и showMyDB(hidden) {  и writeYourGenres() { 
// Теперь у нас есть один большой объект: (personalMovieDB), который 
// содержит свойства:count: 0,  movies: {}, actors: {}, genres: [], privat: false,
// которые описывают эту базу данных
// и методы которые что-то делают либо с внешними данными либо 
// модифицируют нашу БД

// ----------2 задание -----------------------------
//  Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false - он
// переключает его в true, если true - переключает в false. Протестировать вместе с showMyDB.

// создаем метод после (showMyDB: function(hidden) {)
// даем название (toggleVisibleMyDB: function() {)
// создаем классический тогглер(шаблон который используется в javascript)
// который будет опираться на определенные свойства, проверяем условия
// если приватность установлена- мы ее выключаем, если не устанолена
// приватность - включаем.
// Как это работает: сейчас значение privat: false, если оно попадает 
// в (toggleVisibleMyDB: function() {) то срабатывает (} else) - 
// т.е. условие не выполнится: переключаем на true; (false поменяется на true)
// если наоборот переключаем на false.
// проверяем в браузере: в консоли набираем personalMovieDB.start
// на странице появится promt с запросом: отвечаем: 123
// опять запускаем (набираем) personalMovieDB:
// получим: {count: 123, movies: {…}, actors: {…}, genres: Array(0), privat: false, …
// видим что privat: false и его надо поменять
// набираем personalMovieDB.toggleVisibleMyDB(); enter
// запускаем personalMovieDB
// получим:{count: 0, movies: {…}, actors: {…}, genres: Array(0), privat: true, …}
// Значение поменялось на privat: true
// Когда наберем personalMovieDB.showMyDB(personalMovieDB.privat);
// то у нас ничего не появится
// Если повторим personalMovieDB.toggleVisibleMyDB(), то privat: true
// превратится в false и при повторе personalMovieDB.showMyDB(personalMovieDB.privat)
// раскроется в консоли структура БД.
// 2 задание выполнено
// К сведению: когда работаем в консоли браузера каждый раз выходит:
// undefined(если в консоли VSCode такого нет), дело в том что
// команда console.log ничего не возвращает(она запускается, что-то делает
// у нее нет ключевого слова return) и поэтому при работе в консоли 
// браузера всегда после того как что-то отработало выходит undefined.

// --------3 задание-------------------------------
//  В методе writeYourGenres запретить пользователю нажать кнопку "отмена" или оставлять пустую строку. 
// Если он это сделал - возвращать его к этому же вопросу. После того, как все жанры введены - 
// при помощи метода forEach вывести в консоль сообщения в таком виде:
// "Любимый жанр #(номер по порядку, начиная с 1) - это (название из массива)"*/


       //    let genre = prompt(`Ваш любимый жанр под номером ${i}`);
 
       //    if (genre === '' || genre == null) {
 
       //       console.log('Вы ввели некорректные данные или не ввели их вовсе');
       //       i--;
       //    }else {
       //         personalMovieDB.genres[i - 1] = genre;
       //    } 
       
      //
 
 
 /*
 Цикл у нес есть (writeYourGenres: function() { ) и нам необходимо добавить условие и чтобы проверить результат ответа 
от пользователя.
 нам понадобится другая переменная (let genre(жанр)) и в него вырежем и вставим 
 (prompt(`Ваш любимый жанр под номером ${i}`);) 
 и вместо вырезанного (prompt(`Ваш любимый жанр под номером ${i}`);) запишем genre,
 т.е. создали промежуточную переменную. Дальше запишем условие:
 если у нас жанр будет - пустой строкой ставим условный оператор или(||)
 и пропишем что genre не должен равен null. Раскрываем условие({}), если
 это произошло(пользователь нажал кнопку "отмена" или оставил пустую строку) в консоль 
 выведем выражение('Вы ввели некорректные данные') и необходимо откатится(возвранится) 
 на 1 иттерацию(повторение) назад(i--). Если все в порядке перезаписываем (personalMovieDB.genres[i - 1] = genre;).
  Запмсываем в массив наших жанров - новый жанр. Цикл отработает(мы запишем 3 ответа).
 далее по заданию: при помощи метода forEach должны вывести на экран жанры,
 под какими номерами.
    Мы берем базу данных(personalMovieDB) обращаемся к массиву жанров(.genres)
 запускаем метод forEach() и во внутрь нам надо запустить callback-функцию
 при помощи стрелочной функции (чаще всего в callback-функции передаются в таком виде), открываем () и 
 записываем аргументы, с которыми будем взаимодействовать(item, i). item -это каждый элемент в массиве, 
 который мы перебираем(жанр1, жанр2) (i - это номер попорядку).Когда мы так передали аргументы, 
 записали стрелочную функцию и раскрыли фигурные скобки и записать.
 действия, которые нам нужно сделать: в console.log() запишем предложение
 ("Любимый жанр #(номер по порядку, начиная с 1) - это (название из массива))
 из условия задачи в бэктиках(`` косых кавычках), далее
 Любимый жанр ${} и  указать номер в {i + 1} - т.к. нумерация начинаеися с 0,
 для удобство пользователя +1, чтобы начиналось с 1 (1, 2, 3, и т.д.). И дальше название из массива ${`item`}
    Проверим в браузере:
    набираем в консоли personalMovieDB.toggleVisibleMyDB(); enter
 
 3 задание выполнено
 */
 // Альтернативный вариант:
 /*
 Закомментируем:
       //    let genre = prompt(`Ваш любимый жанр под номером ${i}`);
 
       //    if (genre === '' || genre == null) {
 
       //       console.log('Вы ввели некорректные данные или не ввели их вовсе');
       //       i--;
       //    }else {
       //         personalMovieDB.genres[i - 1] = genre;
       //    }  
       // } 
 
 Все делаем внутри цикла 
 вместо закомментированого запишем: 
 let genre = prompt(`Введите ваши любимые жанры через запятую`);  
 дальше понадобится условия,
 if (genre === '' || genre == null) {
             console.log('Вы ввели некорректные данные или не ввели их вовсе');
             i--;
          }else {
             personalMovieDB.genres[i - 1] = genre;
          }
       }
 где будем проверять строку, тут не надо будет 3 запускать цикл, но при 
 этом сохранить возможность откатиться на 1 цикл назад на 1 иттерацию.
 Тут можно сделать так: заменим (for (let i = 1; i <= 3; i++) {) на
 (for (let i = 1; i < 2; i++) {) - цикл запускается 1 раз и завершается.
    Теперь подкорректируем строку:personalMovieDB.genres[i - 1] = genre; на
 строку personalMovieDB.genres = genre.split(', ');
 .split - метод который разбивает строку на отдельные элементы массивов
 через определенный разделитель(у нас запятая).
 Что происходит: 
 мы задаем пользователю 1 вопрос(`Введите ваши любимые жанры через запятую`)
 ответ попадает в переменную genres? потом все проверям 
 ( if (genres === '' || genres == null), если что-то неправильно-откатываемся назад,
 Если все верно:  разбиваем строку(genres.split(', ');) на отдельные 
 элементы массива и результат поместится в personalMovieDB.genres
 Также можно добавить метод sort.
 
 */ 

 // ------Урок 25 ---------------------------------------
 // ------Отлавливаем ошибки в своем коде при помощи консоли разработчика
 /*
 В браузере во вкладке sources 
 Как получить промежуточные разультаты которые возникают на том или ином 
 шаге программы для этого есть вкладка sources:
 здесь можем устанавливать брейкпоинты (это метка которая позволяет 
останавливать код в определенном участке)
Чтобы установить метку выбираем строчку кода и кликаем на нее,
чтобы метка сработала надо перезапустить страницу
 */

 // ---------Урок 26 ----------
 // --------Динамическая типизация в JS -----
 /*
 Динамическая типизация - это возможность одного типа данных 
 превращаться в другой (число стать строкой и т.д.)
 Также есть статическая типизация (когда число остается числом)
 */

 // То String - чтото превратить в строку

 // 1) Самый старый и редко используемый
 //console.log(typeof(String(null)));
 //console.log(typeof(String(4)));

 // 2) Конкатенация (когда что-то складываем со строкой)
 // когда что-то складываем со строкой - всегда получается строка

 //console.log(typeof(5 + ''));

//  const num = 5;

 //console.log("https://vk.com/catalog/" + num);

 //const fontSize = 26 + 'px';

// To Number - что угодно превратить в число

// 1)
//console.log(typeof(Number('4')));

// 2) Унарный плюс(знак + перед каким-то другим типом данных)
//console.log(typeof(+'4'));

// 3) При помощи метода которые есть у чисел

//console.log(typeof(parseInt("15px", 10)));

//let answ = +prompt("Hello", "");
// Все данные получаемые от пользователя всегда будет типом данных -строка
// (значения из prompt, данные из тегов input, textarea, форм и прочие
// - все это строки) и эти строки надо преобразовывать в другой тип данных

// To boolean - самый интересный способ
/* По логике если перед нами пустота - null всегда будет ложью,
и в JS есть одно условное разделение на логические типы.
Запишем то что будет всегда превращаться в неправду- false(0)
*/
//0, '', (если внутри кавычек будет пробел ' ' то это будет непустая строка
//null, undefined, NaN; - все это будет превращаться в false

// Все остальное что есть в JS - true(это пустые массивы, пустые объекты,
// строки и все остальное будет правдой в логическом контексте)
// Напишем пример

// такой прием встречается в программах, когда изначально какая-то переменная
// какой-то переключатель ничего не содержит, чтобы в будущем этот переключатель
// поменяет значение и будет влиять на программу

// 1) Нативный
//let switcher = null;

//if (switcher) {
//   console.log('Working...');
//}
// если запустим этот код он на запустится - т.к. 
// switcher - null(неправда)
// но switcher в ходе программы может поменять значение, например

//switcher = 1;

//if (switcher) {
//   console.log('Working...');
//}
// точно такой прием используется при работе с элементами на странице:
// когда какого-то элемента просто на странице не существует, вместо 
// него будет null, программа работает проверяет условия и на каком-то этапе
// этот элемент появляется, то есть в переменной появился новый элемент(1),
// опять проверяется условие, видит что элемент появился на странице
// и начинает выполнять действие

// Еще 2 способа логических преобразований

// 2)

//console.log(typeof(Boolean('4'))); // логический тип(редко пользуются)

// 3)

//console.log(typeof(!!"44444")); // очень редкий прием


//----------Урок 27----------------------------------
// Задачи с собеседований на понимание основ

// 1)   Какое будет выведено значение: let x = 5; alert( x++ ); ?

//let x = 5; alert( x++ ); 

// Постфиксная форма записи выведет 5, т.к. сперва возвращает исходное значение,
// а потом увеличивает на 1


// Если поменяем местами ++
 
// let x = 5; alert( ++x );

// Префиксная форма сразу выведет 6, т.е. возвращает сразу измененный результат



// 2) 	Чему равно такое выражение: [ ] + false - null + true ?

// [ ] + false - null + true - разобъем на части
// это простые математические операторы и выполняются друг за другом

// console.log(typeof([] + false));
// получаем false? при помощи typeof определяем значение (строка или булиновая)
// получим string
// есть особенность: если работаем с пустым массивом [] он будет приведен к 
// пустой строке "" и складываем с false.
// по уроку о динамической типизации если строку складываем(конкатенируем)
// с другим типом данных - то получаем string (строку) - "false"

//console.log([] + false - null);

// получаем NaN - не математическое выражение( от строки отнимем другой тип данных)
 
//console.log([] + false - null + true);

// получаем NaN - не математическое выражение

// 3) 	Что выведет этот код: let y = 1; let x = y = 2; alert(x); ?

// let y = 1; 
// let x = y = 2; 
// alert(x);
// получим 2
// сперва присваиваем y = 2, а затем x = 2( читаем спава налево)
// последовательное присваивание

// 4)	Чему равна сумма [ ] + 1 + 2?

// [ ] + 1 + 2;

// console.log([] + 1 + 2);

// получим  строку "12"( пустой массив это строка, при контенкатенации
// с 1 - получим строку "1", сконкатенируем строку "1" и число 2 получим
// строку "12")

// 5) 	Что выведет этот код: alert( "1"[0] )?

// alert( "1"[0] );

// получим строку "1" (имеем строку"1" и индекс 0, когда разбирали строки
// каждому элементу строки можно обратиться по индексу, т.к. индекс 0 (т.е.
// первый символ, то ему соответствует "1")

// 6) 	Чему равно 2 && 1 && null && 0 && undefined ?

// console.log(2 && 1 && null && 0 && undefined);

// получим null.(&& - логический оператор И(применяется в условных конструкциях
// чтобы проверить что это выражение верно и то выражение верно(пример:
//  и тот инпут заполнен и тот чек-бокс отмечен и в таком случае можем отправлять
// форму)(Особенность && в том он запинается на лжи) Он начинает слева:
// проверяет 2 - правда, дальше 1 - правда, дальше  null(всегда дает false (ничто) - 
// неправда) т.е. оператор наткнулся на ложное выражение и поэтому всегда будет 
// его возвращать, дальше код не пойдет т.к. ему уже нужно )

// 6) •	Есть ли разница между выражениями? !!( a && b ) и (a && b)?

// console.log(!!( 1 && 2 ) === (1 && 2));

// получим false. т.к. !! превращает слудущее за ним выражение в булиновое
// и булиновое выражение не равно другому выражению

// И запинается на лжи
// ИЛИ запинается на правде

// 7)  Что выведет этот код: alert( null || 2 && 3 || 4 ); ?
//                3
// alert( null || 2 && 3 || 4 );

// Что выведет код из 2 логических операторов? 
// Чтобы узнать какой оператор сработает первым- надо смотреть
// таблицу приоритетов операторов( в гугле ищем таблицу приоритетов операторов)
// в таблице видим &&-(6) - имеет высший приоритет чем ||-(5)
// в 2 && 3 - если оба аргумента равны то оператор возвращает последнее значение
// - результатом этого будет 3.
// Теперь сравниваем null || 3 - (ИЛИ запинается на правде) - 
// результатом будет - 3
// Далее после сравнений остается 3 || 4 - (ИЛИ запинается на правде) - 
// в результате возвращается - 3.
// Итоги:  1. Работает Правило: И запинается на лжи. ИЛИ запинается на правде.
//         2. Смотрим таблицу приоритетов
//         3. Разбиваем задачу на мелкие части по приоритету выполнения

// 8)  	a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?

// const a = [1, 2, 3];
// const b = [1, 2, 3];

// console.log( a == b); // получим false
// т.к. сравниваем две различных переменных(два разных хранилища данных
// (ящик a и ящик b)) - это абсолютно разные хранилища которые хранят разную 
// информацию и не важно что похожая информация (тут мы не сравнивем элементы
// хранилищ)

// 9) 	Что выведет этот код: alert( +"Infinity" ); ?

// alert( +"Infinity" );
// выведет строку "Infinity", хотя это будет число( потому что впереди стоит 
// унарный плюс +)

// 10) 	Верно ли сравнение: "Ёжик" > "яблоко"?

// console.log ("Ёжик" > "яблоко");
// получим false.(Это особенности Unicode). Надо смотреть таблицу символов Unicode

// 11)  Чему равно 0 || "" || 2 || undefined || true || false ?

//alert(0 || "" || 2 || undefined || true || false);
// или
//console.log(0 || "" || 2 || undefined || true || false);

// получим 2. Смотрим правила: И запинается на лжи. ИЛИ запинается на правде.
// 0 - это false, "" - это тоже false, далее 2 -это true, дальше код
// не пойдет и возвращает 2.


//----------Урок 28----------------------------------
// Получение элементов со страницы

/*
Работаем с DOM элементами
В консоли браузера набираем слово document. - и увидим список
свойств и методов присущих этому глобальному объекту
*/

// создаем вместилище информации и в переменную box и в нее
// необходимо поместить элемент, которых хотим получить со страницы
// (Эти методы для получения элементов можно разделить на две группы:
// это те которые существовали давно и те которые появились недавно)
// самый изверстный метод: getElementById
// document. существует только внутри браузера(в консоли vscode
// работать не будет) 

//const box = document.getElementById('box');

//console.log(box);

// getElementById( get-найди, Element-один элемент,ById-по ID)
// также можно получить по тегам(одинаковых тегов очень много)
// С тегами все по другому, если будем искать по тегам то получим
// коллекцию: псевдомассив(синтаксически тоже самое что и массивы
// но без всех методов)
// найдем все кнопки:

//const btns = document.getElementsByTagName('button');

//console.log(btns);

// получим HTMLCollection из 5 кнопок- массиво подобный элемент
// в [] скобках каждый элемент которого имееет свой индекс - 
// больше в коллекции нет методов и свойств.
// И как получить каждую отдельную кнопку, для этого заходим в код
// и должны указать индекс того элемента который нужен:
// 1 способ - после ставим квадратные скобки
// const btns = document.getElementsByTagName('button')[1];
// console.log(btns); // получим <button>2</button>

// 2 способ -
// const btns = document.getElementsByTagName('button');
// console.log(btns[1]);   // получим <button>2</button>

// Помимо тегов можно использовать классы

// const circles = document.getElementsByClassName('circle');
// console.log(circles);

// также получим HTMLCollection

// Переходим к более современным методам


// внутрь  скобок помещаем css - селектор : любой селектор
// который понадобится - это может уникальный идентификатор через #,
// просто класс, вложенность классов, псевдоклассы, атрибуты,
// комбинации всего этого
// У этого метода один большой плюс( ранее говорили что у 
// псевдомассивов нет методов и свойств) у querySelectorAll - 
// исключение, у него есть метод который назывется forEach

// const hearts = document.querySelectorAll('.heart');

//console.log(hearts);

// получим NodeList(3) [div.heart, div.heart, div.heart]

// hearts.forEach(item => {
//    console.log(item);
// });

// рассмотрим querySelector - позволяет получить один элемент со
// страницы, который попал первым

// const oneHeart = document.querySelector('.heart');
// console.log(oneHeart);



//------------Урок 29--------------------------------
// Действия с элементами на странице

// const box = document.getElementById('box');
// const btns = document.getElementsByTagName('button');
// const circles = document.getElementsByClassName('circle');
// const wrapper = document.querySelector('.wrapper');
// const hearts = document.querySelectorAll('.heart');
// const oneHeart = document.querySelector('.heart');


// будем изменять стили этих элементов
// чтобы понять что можем сделать с тем или иным элементом на странице
// посмотрин на него в качестве объекта

// console.dir(box);

// в консоли браузера получим объект - div#box.box.
// в методах и свойствах находим style: CSSStyleDeclaration
// и раскрываем его это объект в объекте - все свойства пока пустые и
// это инлайн свойства, будем работать с этими свойствамиЖ

// box.style.backgroundColor = 'blue';
// box.style.width = '500px';

// btns[1].style.borderRadius = '100%';

// распространенная ошибка:

//circles.style.backgroundColor = 'red';
// т.к. мы обратились ко всему псевдомассиву ничего не произойдет
// нужно писать также
// circles[0].style.backgroundColor = 'red';

// Как назначить несколько инлайн стилей?
// Для этого есть cssText

// box.style.cssText = 'background-color:blue; width: 500px';

// сюда мы можем подставлять переменные,для этого одинарные('')
// кавычки меняем на бэктики (``)

// box.style.cssText = `background-color:blue; width: ${num}px`;

// Если нужно сразу над несколькими элементами произвести одни и теже действия
// Применяют в простом варианте - цикл, также перебирающую конструкцию
// forOff или метод forEach(только при querySelectorAll)

// for (let i = 0; i < hearts.length; i++) {
// (в массивах i=0 т.к. нумерация начинается с 0)
// цикл будет работать до тех пор остануться элементы (псевдо)массива
// i < hearts.length;(количество элементов в псевдомассиве)
// цикл будет работать до тех пока эти элементы есть в псевдомассиве i++,
// Теперь чтобы что-то сделать с каждым элементом внутри, прописываем:
//    hearts[i].style.backgroundColor = 'blue';
// }
// циклы используются редко, для этого есть специальные перебирающие методы
// В скобках передаем колбэк, каждый элемент назовем item
// в колбэке второй аргумент обозначает номер по порядку,
// а третий имеет ссылку на массив который перебираем
// hearts.forEach(item => {
//    item.style.backgroundColor = 'blue';
// });

// Основные методы для работы с элементами страницы
// Очень часто части  сайта создаются, генерируются при помощи JS,
// на таких принципах построен реакт(вся верстка состоит из скриптов),
// т.е. элементы созданы при помощи скрипта
// Мы должны уметь создавать такие новые элементы, для этого используется
// метод: document.createElement

// const div = document.createElement('div');
// во внутрь должны поместить нзвание тега, который создаем
// и он существует только внутри JS(не забываем), на странице не появиться
// также создаем текстовые узлы- это элементы без оболочки тега
// Например:

//const text = document.createTextNode('Тут был Node');
// во внутрь помещаем нужный текст в эту Node,т.е. узел 
// Часто будем слышать не элементы на странице, а Node
// Этот метод используется редко

// Теперь когда элемент существует в JS, его можем стилизовать -
// добавить визуальную оболочку.
// Если хотим элемент полностью кардинально поменять, то чаще всего
// не прописываем целую кучу style и даже не используем cssText
// мы модифицируем css-классы элементов(можем добавить или удалить)

// Есть простое свойство className где через пробел указываем классы и
// добавить к элементу(не рекомендуется), вместо него есть другое
// мощное средство classList, где через точку можем писать действия
// с нашим классом - удаление, добавление и переключение, проверку
// на содержание и даже определение количества примененных классов к элементу
// Например:

// div.classList.add('black');
// элемент создан, и он лежит в коробке, которая есть только  внутри JS,
// к html никакого отношения не имеет и на странице его нет - здесь
// воспользуемся деревом-DOM(любой элемент можно вставить в конец,
// вставить после определенного элемента, удалить или заменить. Но только
// по отношению к другому элементу)

// Современные методы работы с элементами страницы

// Для добавления в конец элемента родителя
// добавим наш div в конец body, чтобы он там появился на странице
// document.body.append(div);

// еще один способ получения элемента если переменная используется
// один раз
// document.querySelector('.wrapper').append(div);

// если переменная используется еще раз, то записываем в начале где
// прописаны все переменные (const) в начале кода.
// wrapper.append(div);

// Обратный метод append - prepend
// Для добавления в начало элемента родителя

// wrapper.prepend(div);

// Также есть методы: before и after (вставить перед и вставить после)
// сначала необходимо сказать перед каким элементом будем устанавливать,

// hearts[0].before(div);
// hearts[0].after(div);

// Также удалить со страницы - remove

// circles[0].remove();

// Замена одного элемента другим - replaceWith. Сперва указываем 
// какой элемент удаляем, в скобках (каким заменяем)
// 

// hearts[0].replaceWith(circles[0]);

// Устаревшие конструкции 

// Для добавления
// wrapper.appendChild(div);


// Вместо метода before
// wrapper.insertBefore(div, hearts[1]);
// в скобках (первый что вставляем, второй- перед каким вставляем )

// Удалить со страницы
// wrapper.removeChild(hearts[1]);

// Замена одного элемента другим
// wrapper.replaceChild(circles[0], hearts[0]);


// Как добавлять текст или html-код прямо в элементы

// const div = document.createElement('div');

// div.classList.add('black');

// wrapper.prepend(div);

// есть элемент div, у него есть класс 'black' и приступим к редактированию
// Например запишем в него текст
// 2 варианта:
// 1 вариант - innerHTML - можно работать с текстом и html

// div.innerHTML = "<h1>Hello World</h1>";

// 2 вариант - textContent - работает только с тексом?
// сделано с целью безопасности: данные которые мы получаем от пользователя
// при помощи модального окна, в каком-то вопросе - и если используется 
// innerHTML - пользователь введя html-структуру может сломать верстку,
// или введя какой-нибудь скрипт приведет к негативным последствиям

// div.textContent = "Hello";

// Комбинация всех знаний которые были выше:
// Как вставить кусочек html-кода перед или после определенных тегов?
// это метод - insertAdjacentHTML

// div.innerHTML = "<h1>Hello World</h1>";

// div.insertAdjacentHTML('afterend', '<h2>Hello</h2>');
// 1 аргумент - специальное слово:
// beforebegin - вставить непосредственно перед элементом div
// afterbegin - вставляет в начало элемента div
// beforeend - вставляет в конце элемента div
// afterend - вставляет после элемента div

// 2 аргумент - html-код который хотим вставить

// Неочевидная возможность JS по получению элементов:
// когда мы получали элементы, например:


// мы каждый раз получали доступ к  document. но при этом не 
// всегда необходим  доступ через  document.
// у нас есть wrapper, внутри него div, его получение (const wrapper)
// и если есть такой родитель wrapper - то я могу сказать, что прямо
// внутри этого блока wrapper - мне необходимо получить определенные
// элементы:
// const wrapper = document.querySelector('.wrapper'); 
// const hearts = wrapper.querySelectorAll('.heart');
// const oneHeart = wrapper.querySelector('.heart');
// то есть вместо document. - записываем wrapper.
// т.е. точно говорим внутри чего ищем


/* Задания на урок:

1) Удалить все рекламные блоки со страницы (правая часть сайта)

2) Изменить жанр фильма, поменять "комедия" на "драма"

3) Изменить задний фон постера с фильмом на изображение "bg.jpg". Оно лежит в папке img.
Реализовать только при помощи JS

4) Список фильмов на странице сформировать на основании данных из этого JS файла.
Отсортировать их по алфавиту 

5) Добавить нумерацию выведенных фильмов */


// const movieDB = {
//     movies: [
//         "Логан",
//         "Лига справедливости",
//         "Ла-ла лэнд",
//         "Одержимость",
//         "Скотт Пилигрим против..."
//     ]
// };

// Практика
// 1) Удалить все рекламные блоки со страницы (правая часть сайта)
// в консоли находим класс рекламного блока с картинками
// копируем класс и создаем константу adv с поиском выбранного класса
// при помощи querySelectorAll

// const adv = document.querySelectorAll('.promo__adv img');
// const poster = document.querySelector('.promo__bg');
// const genre = poster.querySelector('.promo__genre');
// const movieList = document.querySelector('.promo__interactive-list');

// Вариант со стрелочной функцией
// предпочтительнее для использования

// adv.forEach(item => {
//    item.remove();
// });

// Вариант с обычной функцией
// adv.forEach(function (item) {
//    item.remove();
// });
// это безымянная функция, которая создается здесь и сейчас
// и принимает только один аргумент item? который приходит из
// псевдомассива

// 2) Изменить жанр фильма, поменять "комедия" на "драма"
// создаем переменную genre и записываем в одной структуре с 
// остальными переменными в начале кода
// т.к. блок .promo__genre, с которым мы будем работать сейчас 
// находится в блоке .promo__bg,с которым будем работать после
// 2 задания, то в структуре переменных создадим новую переменную
// poster(poster = document.querySelector('.promo__bg')
// т.е. можно четко сказать что блок .promo__genre находится в
// блоке .promo__bg(genre = poster.querySelector('.promo__genre').)

// т.к. изменяем только текст применим textContent

// genre.textContent = 'драма';

// 3) Изменить задний фон постера с фильмом на изображение "bg.jpg". Оно лежит в папке img.
// Реализовать только при помощи JS

// poster.style.backgroundImage = 'url("img/bg.jpg")';

// 4) Список фильмов на странице сформировать на основании данных 
//    из этого JS файла.
// Отсортировать их по алфавиту 

// Мы берем названия фильмов из массива movies и помещаем их
// каким-то образом на страницу
// Сперва удалим элементы со страницы(статичная верстка) чтобы
// они не мешали. Нужно найти родителя удаляемых элементов
// и записать в переменную (const moviList = document.querySelector('.promo__interactive-list');
// чтобы полностью очистить этот элемент, есть метод innerHTML

// movieList.innerHTML = "";

// если поставить- "" - (ничего) - то элемент очистится и ничего не 
// будет содержать.

// теперь сортировка по алфавиту:

// movieDB.movies.sort();
// теперь все отсортировано по алфавиту.
// далее необхоимо сформировать верстку при помощи JS
// и поместить на страницу

// Все элементы с которыми будем взаимодействовать находятся в
// базе данных movieDB в свойстве movies, нам надо будет перебрать все 
// значения, которые находятся в массиве:
// const movieDB = {
//    movies: [
//        "Логан",
//        "Лига справедливости",
//        "Ла-ла лэнд",
//        "Одержимость",
//        "Скотт Пилигрим против..."
//    ]
// };
// и уже на их основании сформировать структуру
// поэтому если мы проговариваем, что нам надо необходимо перебрать 
// прописываем метод forEach, во внутрь прописываем колбэк-функцию,
// здесь понадобиться 2 аргумента: film(это каждый фильм в массиве),
// и переменная i(номер по порядку, т.к. в 5 задании нужно добавить 
// нумерацию)
// Какой самый оптимизированный способ помещать элементы и генерировать
// их вручную, это прописывать их строками и просто добавлять еще
// каждый раз строку, когда повторяется цикл
// (помимо этого есть еще вариант, когда вручную создаем каждый отдельный
//  элемент при помощи createElement, добавляем класс, добавляем 
// внутренность на основании массива и уже потом помещаем на страницу,
// но это не очень оптимизированный вариант - слишком много операций -
// это тоже рабочий вариант) 

// movieDB.movies.forEach((film, i) => {
//    movieList.innerHTML += `
//       <li class="promo__interactive-item">${i + 1} ${film}
//          <div class="delete"></div>
//       </li>
//    `;
// });

// нам необходимо всю верстку, которую сформируем поместить на страницу
// для этого есть блок movieList - который ранее почистили
// потом чтобы туда поместить html - прописываем innerHTML,
// дальше воспользуемся оператором  +=(дополнительное присваивание
// смотри таблицу операторов) - это сокращенная форма для записи
// определенной конструкции. Как это работает пример:
/*
Если у нас есть переменная a, в которую я хочу записать ее предыдущее
значение a только + 1, то можем записать такое выражение:
a = a + 1;
но также есть облегченный синтаксис
a += 1;
или
a = a + "aaa";
a += "aaa";
*/
/*
Особенность innerHTML - научились очищать элемент(movieList.innerHTML = "";),
но при этом также можем получать весь контент, который находится 
внутри определенного элемента, посмотрим как это выглядит:

console.log(poster.innerHTML);(используется не так уж часто)

и дальше ничего не присваиваю, т.е. только прописываю свойство
и помним что наш элемент объект у него есть свойство innerHTML 
если так к нему обращаемся, то просто получаем значение этого свойства
в консоли браузера

Когда имеем такую конструкцию
movieDB.movies.forEach((film, i) => {
   movieList.innerHTML +=
});
каждый раз когда будет цикл (film, i) повторяться
в  movieList.innerHTML += сюда будем добавлять и еще добавлять
какието-то строки
затем после movieList.innerHTML += поставим бэктики(``) потому-что
будем добавлять еще определенные переменные в том числе i.
Теперь посмотрим какую верстку нужно сформировать, находим
li с item которые с фильмами, скопируем последний и вставим 
в бэктики (``), так как прямо здесь же генерируем такую верстку,
если оставим все так:

movieDB.movies.forEach((film, i) => {
   movieList.innerHTML += `
      <li class="promo__interactive-item">СКОТТ ПИЛИГРИМ ПРОТИВ...
         <div class="delete"></div>
      </li>
   `;
});
то forEach повториться 5 раз и каждый раз будет записываться такая
структура:

   <li class="promo__interactive-item">СКОТТ ПИЛИГРИМ ПРОТИВ...
      <div class="delete"></div>
   </li>
и увидим что сформировалось 5 элементов, они не динамичные,
каждый раз при переборе forEach записывали новый элемент в виде строки
(строка на странице при помощи innerHTML интерпретируется как верстка)
если уберем +, то каждый раз на каждом цикле, на каждой иттерации
будет замещаться это значение, в итоге получим только один элемент 
 и дополним в зависимости от того что есть в базе данных
 мы находим то что написано внутри этого элемента:
 СКОТТ ПИЛИГРИМ ПРОТИВ... удаляем его
 и вместе с 5 заданием добавим нумерацию просмотренных фильмов:
у нас есть переменная i(номер по порядку) - ставим знак интерполяции
${i + 1} -то есть начнем с 1 и до последнего фильма

теперь о самом фильме: у нас есть переменная film(еще у нас не используется)
по факту film это будет каждый элемент который лежит в внутри массива
movies, а внутри массива лежит строка, надо ее взять и поместить на страницу
ставим пробел и запишем ${film} и теперь наши фильмы будут формироваться
динамически: ${film} - будет идти из массива каждого элемента, а 
${i + 1} - нумерация будет автоматически
*/



